{"ast":null,"code":"/* parser generated by jison 0.6.1-215 */\n\n/*\r\n * Returns a Parser object of the following structure:\r\n *\r\n *  Parser: {\r\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n *               the real \"shared state\" `yy` passed around to\r\n *               the rule actions, etc. is a derivative/copy of this one,\r\n *               not a direct reference!\r\n *  }\r\n *\r\n *  Parser.prototype: {\r\n *    yy: {},\r\n *    EOF: 1,\r\n *    TERROR: 2,\r\n *\r\n *    trace: function(errorMessage, ...),\r\n *\r\n *    JisonParserError: function(msg, hash),\r\n *\r\n *    quoteName: function(name),\r\n *               Helper function which can be overridden by user code later on: put suitable\r\n *               quotes around literal IDs in a description string.\r\n *\r\n *    originalQuoteName: function(name),\r\n *               The basic quoteName handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    describeSymbol: function(symbol),\r\n *               Return a more-or-less human-readable description of the given symbol, when\r\n *               available, or the symbol itself, serving as its own 'description' for lack\r\n *               of something better to serve up.\r\n *\r\n *               Return NULL when the symbol is unknown to the parser.\r\n *\r\n *    symbols_: {associative list: name ==> number},\r\n *    terminals_: {associative list: number ==> name},\r\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\r\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\r\n *    productions_: [...],\r\n *\r\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\r\n *\r\n *               The function parameters and `this` have the following value/meaning:\r\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\r\n *                             to store/reference the rule value `$$` and location info `@$`.\r\n *\r\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\r\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\r\n *                 data from one reduce action through to the next within a single parse run, then you\r\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\r\n *\r\n *                 `this.yy` is a direct reference to the `yy` shared state object.\r\n *\r\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\r\n *                 object at `parse()` start and are therefore available to the action code via the\r\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\r\n *                 the %parse-param` list.\r\n *\r\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\r\n *                             to match this rule. This is *not* the look-ahead token, but the last token\r\n *                             that's actually part of this rule.\r\n *\r\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\r\n *                 the current look-ahead token.\r\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\r\n *\r\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\r\n *\r\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\r\n *\r\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\r\n *\r\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\r\n *                               of an empty object when no suitable location info can be provided.\r\n *\r\n *               - `yystate` : the current parser state number, used internally for dispatching and\r\n *                               executing the action code chunk matching the rule currently being reduced.\r\n *\r\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *                 Also note that you can access this and other stack index values using the new double-hash\r\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\r\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\r\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\r\n *                 to investigate the parse state stack in your action code, which would, for example,\r\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\r\n *                 to the work described here:\r\n *\r\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\r\n *                   In Journées Francophones des Languages Applicatifs.\r\n *\r\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\r\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\r\n *\r\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\r\n *                             constructs.\r\n *\r\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\r\n *                             the `@1` etc. constructs.\r\n *\r\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\r\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\r\n *                             action code did not provide a suitable location info object when such a\r\n *                             slot was filled!\r\n *\r\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\r\n *                             `#1` etc. constructs.\r\n *\r\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\r\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\r\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\r\n *\r\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\r\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\r\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\r\n *                 *reduced*.\r\n *\r\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\r\n *                             *states* such as the one in `yystate`, which are used to represent\r\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\r\n *                             what can I say? If you access this one, you're clearly doing wicked things\r\n *\r\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\r\n *                             grammar definition file.\r\n *\r\n *    table: [...],\r\n *               State transition table\r\n *               ----------------------\r\n *\r\n *               index levels are:\r\n *               - `state`  --> hash table\r\n *               - `symbol` --> action (number or array)\r\n *\r\n *                 If the `action` is an array, these are the elements' meaning:\r\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\r\n *                 - index [1]: GOTO `state`\r\n *\r\n *                 If the `action` is a number, it is the GOTO `state`\r\n *\r\n *    defaultActions: {...},\r\n *\r\n *    parseError: function(str, hash, ExceptionClass),\r\n *    yyError: function(str, ...),\r\n *    yyRecovering: function(),\r\n *    yyErrOk: function(),\r\n *    yyClearIn: function(),\r\n *\r\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n *               See it's use in this parser kernel in many places; example usage:\r\n *\r\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\r\n *                                     parser.collect_expected_token_set(state), true);\r\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\r\n *\r\n *    originalParseError: function(str, hash, ExceptionClass),\r\n *               The basic `parseError` handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    options: { ... parser %options ... },\r\n *\r\n *    parse: function(input[, args...]),\r\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\r\n *               the root action, in which case the parser is acting as a *matcher*).\r\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\r\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n *\r\n *               WARNING:\r\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\r\n *               any attributes already added to `yy` by the jison run-time;\r\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\r\n *               from silently accepting this confusing and potentially hazardous situation!\r\n *\r\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\r\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\r\n *               object and any collision with those will be reported by the lexer via a thrown exception.\r\n *\r\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\r\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\r\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\r\n *               the internal parser gets properly garbage collected under these particular circumstances.\r\n *\r\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\r\n *\r\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\r\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\r\n *               backwards.\r\n *\r\n *               For more info see the documentation comment further below, immediately above this function's\r\n *               implementation.\r\n *\r\n *    lexer: {\r\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\r\n *                             received via a call to the `.setInput(input, yy)` lexer API.\r\n *        EOF: 1,\r\n *        ERROR: 2,\r\n *        JisonLexerError: function(msg, hash),\r\n *        parseError: function(str, hash, ExceptionClass),\r\n *        setInput: function(input, [yy]),\r\n *        input: function(),\r\n *        unput: function(str),\r\n *        more: function(),\r\n *        reject: function(),\r\n *        less: function(n),\r\n *        pastInput: function(n),\r\n *        upcomingInput: function(n),\r\n *        showPosition: function(),\r\n *        test_match: function(regex_match_array, rule_index, ...),\r\n *        next: function(...),\r\n *        lex: function(...),\r\n *        begin: function(condition),\r\n *        pushState: function(condition),\r\n *        popState: function(),\r\n *        topState: function(),\r\n *        _currentRules: function(),\r\n *        stateStackSize: function(),\r\n *        cleanupAfterLex: function()\r\n *\r\n *        options: { ... lexer %options ... },\r\n *\r\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\r\n *        rules: [...],\r\n *        conditions: {associative list: name ==> set},\r\n *    }\r\n *  }\r\n *\r\n *\r\n *  token location info (@$, _$, etc.): {\r\n *    first_line: n,\r\n *    last_line: n,\r\n *    first_column: n,\r\n *    last_column: n,\r\n *    range: [start_number, end_number]\r\n *               (where the numbers are indexes into the input string, zero-based)\r\n *  }\r\n *\r\n * ---\r\n *\r\n * The `parseError` function receives a 'hash' object with these members for lexer and\r\n * parser errors:\r\n *\r\n *  {\r\n *    text:        (matched text)\r\n *    token:       (the produced terminal token, if any)\r\n *    token_id:    (the produced terminal token numeric ID, if any)\r\n *    line:        (yylineno)\r\n *    loc:         (yylloc)\r\n *  }\r\n *\r\n * parser (grammar) errors will also provide these additional members:\r\n *\r\n *  {\r\n *    expected:    (array describing the set of expected tokens;\r\n *                  may be UNDEFINED when we cannot easily produce such a set)\r\n *    state:       (integer (or array when the table includes grammar collisions);\r\n *                  represents the current internal state of the parser kernel.\r\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\r\n *                  API to obtain the expected token set)\r\n *    action:      (integer; represents the current internal action which will be executed)\r\n *    new_state:   (integer; represents the next/planned internal state, once the current\r\n *                  action has executed)\r\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n *                  available for this particular error)\r\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n *                  as is also available in the rule actions; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    lexer:       (reference to the current lexer instance used by the parser)\r\n *    parser:      (reference to the current parser instance)\r\n *  }\r\n *\r\n * while `this` will reference the current parser instance.\r\n *\r\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    lexer:       (reference to the current lexer instance which reported the error)\r\n *  }\r\n *\r\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\r\n * from either the parser or lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    exception:   (reference to the exception thrown)\r\n *  }\r\n *\r\n * Please do note that in the latter situation, the `expected` field will be omitted as\r\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\r\n * action code in either parser or lexer failing unexpectedly.\r\n *\r\n * ---\r\n *\r\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\r\n * These options are available:\r\n *\r\n * ### options which are global for all parser instances\r\n *\r\n *  Parser.pre_parse: function(yy)\r\n *                 optional: you can specify a pre_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`.\r\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: you can specify a post_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\r\n *                 the parser will return the original `retval`.\r\n *\r\n * ### options which can be set up per parser instance\r\n *\r\n *  yy: {\r\n *      pre_parse:  function(yy)\r\n *                 optional: is invoked before the parse cycle starts (and before the first\r\n *                 invocation of `lex()`) but immediately after the invocation of\r\n *                 `parser.pre_parse()`).\r\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: is invoked when the parse terminates due to success ('accept')\r\n *                 or failure (even when exceptions are thrown).\r\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\r\n *                 this function can override the return value by returning another.\r\n *                 When it does not return any value, the parser will return the original\r\n *                 `retval`.\r\n *                 This function is invoked immediately before `parser.post_parse()`.\r\n *\r\n *      parseError: function(str, hash, ExceptionClass)\r\n *                 optional: overrides the default `parseError` function.\r\n *      quoteName: function(name),\r\n *                 optional: overrides the default `quoteName` function.\r\n *  }\r\n *\r\n *  parser.lexer.options: {\r\n *      pre_lex:  function()\r\n *                 optional: is invoked before the lexer is invoked to produce another token.\r\n *                 `this` refers to the Lexer object.\r\n *      post_lex: function(token) { return token; }\r\n *                 optional: is invoked when the lexer has produced a token `token`;\r\n *                 this function can override the returned token value by returning another.\r\n *                 When it does not return any (truthy) value, the lexer will return\r\n *                 the original `token`.\r\n *                 `this` refers to the Lexer object.\r\n *\r\n *      ranges: boolean\r\n *                 optional: `true` ==> token location info will include a .range[] member.\r\n *      flex: boolean\r\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n *                 exhaustively to find the longest match.\r\n *      backtrack_lexer: boolean\r\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n *                 the lexer terminates the scan when a token is returned by the action code.\r\n *      xregexp: boolean\r\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\r\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n *  }\r\n */\nvar parser = function () {\n  // See also:\n  // http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\n  // but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\n  // with userland code which might access the derived class in a 'classic' way.\n  function JisonParserError(msg, hash) {\n    Object.defineProperty(this, 'name', {\n      enumerable: false,\n      writable: false,\n      value: 'JisonParserError'\n    });\n    if (msg == null) msg = '???';\n    Object.defineProperty(this, 'message', {\n      enumerable: false,\n      writable: true,\n      value: msg\n    });\n    this.hash = hash;\n    var stacktrace;\n\n    if (hash && hash.exception instanceof Error) {\n      var ex2 = hash.exception;\n      this.message = ex2.message || msg;\n      stacktrace = ex2.stack;\n    }\n\n    if (!stacktrace) {\n      if (Error.hasOwnProperty('captureStackTrace')) {\n        // V8/Chrome engine\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        stacktrace = new Error(msg).stack;\n      }\n    }\n\n    if (stacktrace) {\n      Object.defineProperty(this, 'stack', {\n        enumerable: false,\n        writable: false,\n        value: stacktrace\n      });\n    }\n  }\n\n  if (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\n  } else {\n    JisonParserError.prototype = Object.create(Error.prototype);\n  }\n\n  JisonParserError.prototype.constructor = JisonParserError;\n  JisonParserError.prototype.name = 'JisonParserError'; // helper: reconstruct the productions[] table\n\n  function bp(s) {\n    var rv = [];\n    var p = s.pop;\n    var r = s.rule;\n\n    for (var i = 0, l = p.length; i < l; i++) {\n      rv.push([p[i], r[i]]);\n    }\n\n    return rv;\n  } // helper: reconstruct the defaultActions[] table\n\n\n  function bda(s) {\n    var rv = {};\n    var d = s.idx;\n    var g = s.goto;\n\n    for (var i = 0, l = d.length; i < l; i++) {\n      var j = d[i];\n      rv[j] = g[i];\n    }\n\n    return rv;\n  } // helper: reconstruct the 'goto' table\n\n\n  function bt(s) {\n    var rv = [];\n    var d = s.len;\n    var y = s.symbol;\n    var t = s.type;\n    var a = s.state;\n    var m = s.mode;\n    var g = s.goto;\n\n    for (var i = 0, l = d.length; i < l; i++) {\n      var n = d[i];\n      var q = {};\n\n      for (var j = 0; j < n; j++) {\n        var z = y.shift();\n\n        switch (t.shift()) {\n          case 2:\n            q[z] = [m.shift(), g.shift()];\n            break;\n\n          case 0:\n            q[z] = a.shift();\n            break;\n\n          default:\n            // type === 1: accept\n            q[z] = [3];\n        }\n      }\n\n      rv.push(q);\n    }\n\n    return rv;\n  } // helper: runlength encoding with increment step: code, length: step (default step = 0)\n  // `this` references an array\n\n\n  function s(c, l, a) {\n    a = a || 0;\n\n    for (var i = 0; i < l; i++) {\n      this.push(c);\n      c += a;\n    }\n  } // helper: duplicate sequence from *relative* offset and length.\n  // `this` references an array\n\n\n  function c(i, l) {\n    i = this.length - i;\n\n    for (l += i; i < l; i++) {\n      this.push(this[i]);\n    }\n  } // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\n\n\n  function u(a) {\n    var rv = [];\n\n    for (var i = 0, l = a.length; i < l; i++) {\n      var e = a[i]; // Is this entry a helper function?\n\n      if (typeof e === 'function') {\n        i++;\n        e.apply(rv, a[i]);\n      } else {\n        rv.push(e);\n      }\n    }\n\n    return rv;\n  }\n\n  var parser = {\n    // Code Generator Information Report\n    // ---------------------------------\n    //\n    // Options:\n    //\n    //   default action mode: ............. [\"classic\",\"merge\"]\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\n    //   try..catch: ...................... true\n    //   default resolve on conflict: ..... true\n    //   on-demand look-ahead: ............ false\n    //   error recovery token skip maximum: 3\n    //   yyerror in parse actions is: ..... NOT recoverable,\n    //   yyerror in lexer actions and other non-fatal lexer are:\n    //   .................................. NOT recoverable,\n    //   debug grammar/output: ............ false\n    //   has partial LR conflict upgrade:   true\n    //   rudimentary token-stack support:   false\n    //   parser table compression mode: ... 2\n    //   export debug tables: ............. false\n    //   export *all* tables: ............. false\n    //   module type: ..................... commonjs\n    //   parser engine type: .............. lalr\n    //   output main() in the module: ..... true\n    //   has user-specified main(): ....... false\n    //   has user-specified require()/import modules for main():\n    //   .................................. false\n    //   number of expected conflicts: .... 0\n    //\n    //\n    // Parser Analysis flags:\n    //\n    //   no significant actions (parser is a language matcher only):\n    //   .................................. false\n    //   uses yyleng: ..................... false\n    //   uses yylineno: ................... false\n    //   uses yytext: ..................... false\n    //   uses yylloc: ..................... false\n    //   uses ParseError API: ............. false\n    //   uses YYERROR: .................... false\n    //   uses YYRECOVERING: ............... false\n    //   uses YYERROK: .................... false\n    //   uses YYCLEARIN: .................. false\n    //   tracks rule values: .............. true\n    //   assigns rule values: ............. true\n    //   uses location tracking: .......... false\n    //   assigns location: ................ false\n    //   uses yystack: .................... false\n    //   uses yysstack: ................... false\n    //   uses yysp: ....................... true\n    //   uses yyrulelength: ............... false\n    //   uses yyMergeLocationInfo API: .... false\n    //   has error recovery: .............. false\n    //   has error reporting: ............. false\n    //\n    // --------- END OF REPORT -----------\n    trace: function no_op_trace() {},\n    JisonParserError: JisonParserError,\n    yy: {},\n    options: {\n      type: \"lalr\",\n      hasPartialLrUpgradeOnConflict: true,\n      errorRecoveryTokenDiscardCount: 3\n    },\n    symbols_: {\n      \"$accept\": 0,\n      \"$end\": 1,\n      \"ADD\": 3,\n      \"ANGLE\": 16,\n      \"CHS\": 22,\n      \"COMMA\": 14,\n      \"CSS_CPROP\": 13,\n      \"CSS_VAR\": 12,\n      \"DIV\": 6,\n      \"EMS\": 20,\n      \"EOF\": 1,\n      \"EXS\": 21,\n      \"FREQ\": 18,\n      \"LENGTH\": 15,\n      \"LPAREN\": 7,\n      \"MUL\": 5,\n      \"NESTED_CALC\": 9,\n      \"NUMBER\": 11,\n      \"PERCENTAGE\": 28,\n      \"PREFIX\": 10,\n      \"REMS\": 23,\n      \"RES\": 19,\n      \"RPAREN\": 8,\n      \"SUB\": 4,\n      \"TIME\": 17,\n      \"VHS\": 24,\n      \"VMAXS\": 27,\n      \"VMINS\": 26,\n      \"VWS\": 25,\n      \"css_value\": 33,\n      \"css_variable\": 32,\n      \"error\": 2,\n      \"expression\": 29,\n      \"math_expression\": 30,\n      \"value\": 31\n    },\n    terminals_: {\n      1: \"EOF\",\n      2: \"error\",\n      3: \"ADD\",\n      4: \"SUB\",\n      5: \"MUL\",\n      6: \"DIV\",\n      7: \"LPAREN\",\n      8: \"RPAREN\",\n      9: \"NESTED_CALC\",\n      10: \"PREFIX\",\n      11: \"NUMBER\",\n      12: \"CSS_VAR\",\n      13: \"CSS_CPROP\",\n      14: \"COMMA\",\n      15: \"LENGTH\",\n      16: \"ANGLE\",\n      17: \"TIME\",\n      18: \"FREQ\",\n      19: \"RES\",\n      20: \"EMS\",\n      21: \"EXS\",\n      22: \"CHS\",\n      23: \"REMS\",\n      24: \"VHS\",\n      25: \"VWS\",\n      26: \"VMINS\",\n      27: \"VMAXS\",\n      28: \"PERCENTAGE\"\n    },\n    TERROR: 2,\n    EOF: 1,\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\n    // thus helping JIT compilers like Chrome V8.\n    originalQuoteName: null,\n    originalParseError: null,\n    cleanupAfterParse: null,\n    constructParseErrorInfo: null,\n    yyMergeLocationInfo: null,\n    __reentrant_call_depth: 0,\n    // INTERNAL USE ONLY\n    __error_infos: [],\n    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    __error_recovery_infos: [],\n    // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\n    // APIs which will be set up depending on user action code analysis:\n    //yyRecovering: 0,\n    //yyErrOk: 0,\n    //yyClearIn: 0,\n    // Helper APIs\n    // -----------\n    // Helper function which can be overridden by user code later on: put suitable quotes around\n    // literal IDs in a description string.\n    quoteName: function parser_quoteName(id_str) {\n      return '\"' + id_str + '\"';\n    },\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    getSymbolName: function parser_getSymbolName(symbol) {\n      if (this.terminals_[symbol]) {\n        return this.terminals_[symbol];\n      } // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\n      //\n      // An example of this may be where a rule's action code contains a call like this:\n      //\n      //      parser.getSymbolName(#$)\n      //\n      // to obtain a human-readable name of the current grammar rule.\n\n\n      var s = this.symbols_;\n\n      for (var key in s) {\n        if (s[key] === symbol) {\n          return key;\n        }\n      }\n\n      return null;\n    },\n    // Return a more-or-less human-readable description of the given symbol, when available,\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\n    //\n    // Return NULL when the symbol is unknown to the parser.\n    describeSymbol: function parser_describeSymbol(symbol) {\n      if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\n        return this.terminal_descriptions_[symbol];\n      } else if (symbol === this.EOF) {\n        return 'end of input';\n      }\n\n      var id = this.getSymbolName(symbol);\n\n      if (id) {\n        return this.quoteName(id);\n      }\n\n      return null;\n    },\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\n    //\n    // The produced list may contain token or token set descriptions instead of the tokens\n    // themselves to help turning this output into something that easier to read by humans\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\n    // expected terminals and nonterminals is produced.\n    //\n    // The returned list (array) will not contain any duplicate entries.\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\n      var TERROR = this.TERROR;\n      var tokenset = [];\n      var check = {}; // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\n      // If so, use that one instead of the less palatable token set.\n\n      if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\n        return [this.state_descriptions_[state]];\n      }\n\n      for (var p in this.table[state]) {\n        p = +p;\n\n        if (p !== TERROR) {\n          var d = do_not_describe ? p : this.describeSymbol(p);\n\n          if (d && !check[d]) {\n            tokenset.push(d);\n            check[d] = true; // Mark this token description as already mentioned to prevent outputting duplicate entries.\n          }\n        }\n      }\n\n      return tokenset;\n    },\n    productions_: bp({\n      pop: u([29, s, [30, 10], 31, 31, 32, 32, s, [33, 15]]),\n      rule: u([2, s, [3, 5], 4, 7, s, [1, 4], 2, 4, 6, s, [1, 14], 2])\n    }),\n    performAction: function parser__PerformAction(yystate\n    /* action[1] */\n    , yysp, yyvstack) {\n      /* this == yyval */\n      // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\n      var yy = this.yy;\n      var yyparser = yy.parser;\n      var yylexer = yy.lexer;\n\n      switch (yystate) {\n        case 0:\n          /*! Production::    $accept : expression $end */\n          // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\n          this.$ = yyvstack[yysp - 1]; // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)\n\n          break;\n\n        case 1:\n          /*! Production::    expression : math_expression EOF */\n          // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\n          this.$ = yyvstack[yysp - 1]; // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\n\n          return yyvstack[yysp - 1];\n          break;\n\n        case 2:\n        /*! Production::    math_expression : math_expression ADD math_expression */\n\n        case 3:\n        /*! Production::    math_expression : math_expression SUB math_expression */\n\n        case 4:\n        /*! Production::    math_expression : math_expression MUL math_expression */\n\n        case 5:\n          /*! Production::    math_expression : math_expression DIV math_expression */\n          this.$ = {\n            type: 'MathExpression',\n            operator: yyvstack[yysp - 1],\n            left: yyvstack[yysp - 2],\n            right: yyvstack[yysp]\n          };\n          break;\n\n        case 6:\n          /*! Production::    math_expression : LPAREN math_expression RPAREN */\n          this.$ = yyvstack[yysp - 1];\n          break;\n\n        case 7:\n          /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */\n          this.$ = {\n            type: 'Calc',\n            value: yyvstack[yysp - 1]\n          };\n          break;\n\n        case 8:\n          /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */\n          this.$ = {\n            type: 'Calc',\n            value: yyvstack[yysp - 1],\n            prefix: yyvstack[yysp - 5]\n          };\n          break;\n\n        case 9:\n        /*! Production::    math_expression : css_variable */\n\n        case 10:\n        /*! Production::    math_expression : css_value */\n\n        case 11:\n          /*! Production::    math_expression : value */\n          this.$ = yyvstack[yysp];\n          break;\n\n        case 12:\n          /*! Production::    value : NUMBER */\n          this.$ = {\n            type: 'Value',\n            value: parseFloat(yyvstack[yysp])\n          };\n          break;\n\n        case 13:\n          /*! Production::    value : SUB NUMBER */\n          this.$ = {\n            type: 'Value',\n            value: parseFloat(yyvstack[yysp]) * -1\n          };\n          break;\n\n        case 14:\n          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */\n          this.$ = {\n            type: 'CssVariable',\n            value: yyvstack[yysp - 1]\n          };\n          break;\n\n        case 15:\n          /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */\n          this.$ = {\n            type: 'CssVariable',\n            value: yyvstack[yysp - 3],\n            fallback: yyvstack[yysp - 1]\n          };\n          break;\n\n        case 16:\n          /*! Production::    css_value : LENGTH */\n          this.$ = {\n            type: 'LengthValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n          };\n          break;\n\n        case 17:\n          /*! Production::    css_value : ANGLE */\n          this.$ = {\n            type: 'AngleValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n          };\n          break;\n\n        case 18:\n          /*! Production::    css_value : TIME */\n          this.$ = {\n            type: 'TimeValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n          };\n          break;\n\n        case 19:\n          /*! Production::    css_value : FREQ */\n          this.$ = {\n            type: 'FrequencyValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n          };\n          break;\n\n        case 20:\n          /*! Production::    css_value : RES */\n          this.$ = {\n            type: 'ResolutionValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: /[a-z]+/.exec(yyvstack[yysp])[0]\n          };\n          break;\n\n        case 21:\n          /*! Production::    css_value : EMS */\n          this.$ = {\n            type: 'EmValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'em'\n          };\n          break;\n\n        case 22:\n          /*! Production::    css_value : EXS */\n          this.$ = {\n            type: 'ExValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'ex'\n          };\n          break;\n\n        case 23:\n          /*! Production::    css_value : CHS */\n          this.$ = {\n            type: 'ChValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'ch'\n          };\n          break;\n\n        case 24:\n          /*! Production::    css_value : REMS */\n          this.$ = {\n            type: 'RemValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'rem'\n          };\n          break;\n\n        case 25:\n          /*! Production::    css_value : VHS */\n          this.$ = {\n            type: 'VhValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'vh'\n          };\n          break;\n\n        case 26:\n          /*! Production::    css_value : VWS */\n          this.$ = {\n            type: 'VwValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'vw'\n          };\n          break;\n\n        case 27:\n          /*! Production::    css_value : VMINS */\n          this.$ = {\n            type: 'VminValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'vmin'\n          };\n          break;\n\n        case 28:\n          /*! Production::    css_value : VMAXS */\n          this.$ = {\n            type: 'VmaxValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: 'vmax'\n          };\n          break;\n\n        case 29:\n          /*! Production::    css_value : PERCENTAGE */\n          this.$ = {\n            type: 'PercentageValue',\n            value: parseFloat(yyvstack[yysp]),\n            unit: '%'\n          };\n          break;\n\n        case 30:\n          /*! Production::    css_value : SUB css_value */\n          var prev = yyvstack[yysp];\n          prev.value *= -1;\n          this.$ = prev;\n          break;\n      }\n    },\n    table: bt({\n      len: u([24, 1, 5, 23, 1, 18, s, [0, 3], 1, s, [0, 16], s, [23, 4], c, [28, 3], 0, 0, 16, 1, 6, 6, s, [0, 3], 5, 1, 2, c, [37, 3], c, [20, 3], 5, 0, 0]),\n      symbol: u([4, 7, 9, 11, 12, s, [15, 19, 1], 1, 1, s, [3, 4, 1], c, [30, 19], c, [29, 4], 7, 4, 10, 11, c, [22, 14], c, [19, 3], c, [43, 22], c, [23, 69], c, [139, 4], 8, c, [51, 24], 4, c, [138, 15], 13, c, [186, 5], 8, c, [6, 6], c, [5, 5], 9, 8, 14, c, [159, 47], c, [60, 10]]),\n      type: u([s, [2, 19], s, [0, 5], 1, s, [2, 24], s, [0, 4], c, [22, 19], c, [43, 42], c, [23, 70], c, [28, 25], c, [45, 25], c, [113, 54]]),\n      state: u([1, 2, 8, 6, 7, 30, c, [4, 3], 33, 37, c, [5, 3], 38, c, [4, 3], 39, c, [4, 3], 40, c, [4, 3], 42, c, [21, 4], 50, c, [5, 3], 51, c, [4, 3]]),\n      mode: u([s, [1, 179], s, [2, 3], c, [5, 5], c, [6, 4], s, [1, 57]]),\n      goto: u([5, 3, 4, 24, s, [9, 15, 1], s, [25, 5, 1], c, [24, 19], 31, 35, 32, 34, c, [18, 14], 36, c, [38, 19], c, [19, 57], c, [118, 4], 41, c, [24, 19], 43, 35, c, [16, 14], 44, s, [2, 3], 28, 29, 2, s, [3, 3], 28, 29, 3, c, [53, 4], s, [45, 5, 1], c, [100, 42], 52, c, [5, 4], 53])\n    }),\n    defaultActions: bda({\n      idx: u([6, 7, 8, s, [10, 16, 1], 33, 34, 39, 40, 41, 45, 47, 52, 53]),\n      goto: u([9, 10, 11, s, [16, 14, 1], 12, 1, 30, 13, s, [4, 4, 1], 14, 15, 8])\n    }),\n    parseError: function parseError(str, hash, ExceptionClass) {\n      if (hash.recoverable) {\n        if (typeof this.trace === 'function') {\n          this.trace(str);\n        }\n\n        hash.destroy(); // destroy... well, *almost*!\n      } else {\n        if (typeof this.trace === 'function') {\n          this.trace(str);\n        }\n\n        if (!ExceptionClass) {\n          ExceptionClass = this.JisonParserError;\n        }\n\n        throw new ExceptionClass(str, hash);\n      }\n    },\n    parse: function parse(input) {\n      var self = this;\n      var stack = new Array(128); // token stack: stores token which leads to state at the same index (column storage)\n\n      var sstack = new Array(128); // state stack: stores states (column storage)\n\n      var vstack = new Array(128); // semantic value stack\n\n      var table = this.table;\n      var sp = 0; // 'stack pointer': index into the stacks\n\n      var symbol = 0;\n      var TERROR = this.TERROR;\n      var EOF = this.EOF;\n      var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = this.options.errorRecoveryTokenDiscardCount | 0 || 3;\n      var NO_ACTION = [0, 54\n      /* === table.length :: ensures that anyone using this new state will fail dramatically! */\n      ];\n      var lexer;\n\n      if (this.__lexer__) {\n        lexer = this.__lexer__;\n      } else {\n        lexer = this.__lexer__ = Object.create(this.lexer);\n      }\n\n      var sharedState_yy = {\n        parseError: undefined,\n        quoteName: undefined,\n        lexer: undefined,\n        parser: undefined,\n        pre_parse: undefined,\n        post_parse: undefined,\n        pre_lex: undefined,\n        post_lex: undefined // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\n\n      };\n      var ASSERT;\n\n      if (typeof assert !== 'function') {\n        ASSERT = function JisonAssert(cond, msg) {\n          if (!cond) {\n            throw new Error('assertion failed: ' + (msg || '***'));\n          }\n        };\n      } else {\n        ASSERT = assert;\n      }\n\n      this.yyGetSharedState = function yyGetSharedState() {\n        return sharedState_yy;\n      };\n\n      function shallow_copy_noclobber(dst, src) {\n        for (var k in src) {\n          if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\n            dst[k] = src[k];\n          }\n        }\n      } // copy state\n\n\n      shallow_copy_noclobber(sharedState_yy, this.yy);\n      sharedState_yy.lexer = lexer;\n      sharedState_yy.parser = this; // Does the shared state override the default `parseError` that already comes with this instance?\n\n      if (typeof sharedState_yy.parseError === 'function') {\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\n          if (!ExceptionClass) {\n            ExceptionClass = this.JisonParserError;\n          }\n\n          return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\n        };\n      } else {\n        this.parseError = this.originalParseError;\n      } // Does the shared state override the default `quoteName` that already comes with this instance?\n\n\n      if (typeof sharedState_yy.quoteName === 'function') {\n        this.quoteName = function quoteNameAlt(id_str) {\n          return sharedState_yy.quoteName.call(this, id_str);\n        };\n      } else {\n        this.quoteName = this.originalQuoteName;\n      } // set up the cleanup function; make it an API so that external code can re-use this one in case of\n      // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\n      // case this parse() API method doesn't come with a `finally { ... }` block any more!\n      //\n      // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n      //       or else your `sharedState`, etc. references will be *wrong*!\n\n\n      this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\n        var rv;\n\n        if (invoke_post_methods) {\n          var hash;\n\n          if (sharedState_yy.post_parse || this.post_parse) {\n            // create an error hash info instance: we re-use this API in a **non-error situation**\n            // as this one delivers all parser internals ready for access by userland code.\n            hash = this.constructParseErrorInfo(null\n            /* no error! */\n            , null\n            /* no exception! */\n            , null, false);\n          }\n\n          if (sharedState_yy.post_parse) {\n            rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\n            if (typeof rv !== 'undefined') resultValue = rv;\n          }\n\n          if (this.post_parse) {\n            rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\n            if (typeof rv !== 'undefined') resultValue = rv;\n          } // cleanup:\n\n\n          if (hash && hash.destroy) {\n            hash.destroy();\n          }\n        }\n\n        if (this.__reentrant_call_depth > 1) return resultValue; // do not (yet) kill the sharedState when this is a reentrant run.\n        // clean up the lingering lexer structures as well:\n\n        if (lexer.cleanupAfterLex) {\n          lexer.cleanupAfterLex(do_not_nuke_errorinfos);\n        } // prevent lingering circular references from causing memory leaks:\n\n\n        if (sharedState_yy) {\n          sharedState_yy.lexer = undefined;\n          sharedState_yy.parser = undefined;\n\n          if (lexer.yy === sharedState_yy) {\n            lexer.yy = undefined;\n          }\n        }\n\n        sharedState_yy = undefined;\n        this.parseError = this.originalParseError;\n        this.quoteName = this.originalQuoteName; // nuke the vstack[] array at least as that one will still reference obsoleted user values.\n        // To be safe, we nuke the other internal stack columns as well...\n\n        stack.length = 0; // fastest way to nuke an array without overly bothering the GC\n\n        sstack.length = 0;\n        vstack.length = 0;\n        sp = 0; // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n\n        if (!do_not_nuke_errorinfos) {\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n            var el = this.__error_infos[i];\n\n            if (el && typeof el.destroy === 'function') {\n              el.destroy();\n            }\n          }\n\n          this.__error_infos.length = 0;\n        }\n\n        return resultValue;\n      }; // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\n      //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\n\n\n      this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\n        var pei = {\n          errStr: msg,\n          exception: ex,\n          text: lexer.match,\n          value: lexer.yytext,\n          token: this.describeSymbol(symbol) || symbol,\n          token_id: symbol,\n          line: lexer.yylineno,\n          expected: expected,\n          recoverable: recoverable,\n          state: state,\n          action: action,\n          new_state: newState,\n          symbol_stack: stack,\n          state_stack: sstack,\n          value_stack: vstack,\n          stack_pointer: sp,\n          yy: sharedState_yy,\n          lexer: lexer,\n          parser: this,\n          // and make sure the error info doesn't stay due to potential\n          // ref cycle via userland code manipulations.\n          // These would otherwise all be memory leak opportunities!\n          //\n          // Note that only array and object references are nuked as those\n          // constitute the set of elements which can produce a cyclic ref.\n          // The rest of the members is kept intact as they are harmless.\n          destroy: function destructParseErrorInfo() {\n            // remove cyclic references added to error info:\n            // info.yy = null;\n            // info.lexer = null;\n            // info.value = null;\n            // info.value_stack = null;\n            // ...\n            var rec = !!this.recoverable;\n\n            for (var key in this) {\n              if (this.hasOwnProperty(key) && typeof key === 'object') {\n                this[key] = undefined;\n              }\n            }\n\n            this.recoverable = rec;\n          }\n        }; // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n\n        this.__error_infos.push(pei);\n\n        return pei;\n      };\n\n      function getNonTerminalFromCode(symbol) {\n        var tokenName = self.getSymbolName(symbol);\n\n        if (!tokenName) {\n          tokenName = symbol;\n        }\n\n        return tokenName;\n      }\n\n      function stdLex() {\n        var token = lexer.lex(); // if token isn't its numeric value, convert\n\n        if (typeof token !== 'number') {\n          token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n      }\n\n      function fastLex() {\n        var token = lexer.fastLex(); // if token isn't its numeric value, convert\n\n        if (typeof token !== 'number') {\n          token = self.symbols_[token] || token;\n        }\n\n        return token || EOF;\n      }\n\n      var lex = stdLex;\n      var state, action, r, t;\n      var yyval = {\n        $: true,\n        _$: undefined,\n        yy: sharedState_yy\n      };\n      var p;\n      var yyrulelen;\n      var this_production;\n      var newState;\n      var retval = false;\n\n      try {\n        this.__reentrant_call_depth++;\n        lexer.setInput(input, sharedState_yy); // NOTE: we *assume* no lexer pre/post handlers are set up *after* \n        // this initial `setInput()` call: hence we can now check and decide\n        // whether we'll go with the standard, slower, lex() API or the\n        // `fast_lex()` one:\n\n        if (typeof lexer.canIUse === 'function') {\n          var lexerInfo = lexer.canIUse();\n\n          if (lexerInfo.fastLex && typeof fastLex === 'function') {\n            lex = fastLex;\n          }\n        }\n\n        vstack[sp] = null;\n        sstack[sp] = 0;\n        stack[sp] = 0;\n        ++sp;\n\n        if (this.pre_parse) {\n          this.pre_parse.call(this, sharedState_yy);\n        }\n\n        if (sharedState_yy.pre_parse) {\n          sharedState_yy.pre_parse.call(this, sharedState_yy);\n        }\n\n        newState = sstack[sp - 1];\n\n        for (;;) {\n          // retrieve state number from top of stack\n          state = newState; // sstack[sp - 1];\n          // use default actions if available\n\n          if (this.defaultActions[state]) {\n            action = 2;\n            newState = this.defaultActions[state];\n          } else {\n            // The single `==` condition below covers both these `===` comparisons in a single\n            // operation:\n            //\n            //     if (symbol === null || typeof symbol === 'undefined') ...\n            if (!symbol) {\n              symbol = lex();\n            } // read action for current state and first input\n\n\n            t = table[state] && table[state][symbol] || NO_ACTION;\n            newState = t[1];\n            action = t[0]; // handle parse error\n\n            if (!action) {\n              var errStr;\n              var errSymbolDescr = this.describeSymbol(symbol) || symbol;\n              var expected = this.collect_expected_token_set(state); // Report error\n\n              if (typeof lexer.yylineno === 'number') {\n                errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\n              } else {\n                errStr = 'Parse error: ';\n              }\n\n              if (typeof lexer.showPosition === 'function') {\n                errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\n              }\n\n              if (expected.length) {\n                errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\n              } else {\n                errStr += 'Unexpected ' + errSymbolDescr;\n              } // we cannot recover from the error!\n\n\n              p = this.constructParseErrorInfo(errStr, null, expected, false);\n              r = this.parseError(p.errStr, p, this.JisonParserError);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n              }\n\n              break;\n            }\n          }\n\n          switch (action) {\n            // catch misc. parse failures:\n            default:\n              // this shouldn't happen, unless resolve defaults are off\n              if (action instanceof Array) {\n                p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\n                r = this.parseError(p.errStr, p, this.JisonParserError);\n\n                if (typeof r !== 'undefined') {\n                  retval = r;\n                }\n\n                break;\n              } // Another case of better safe than sorry: in case state transitions come out of another error recovery process\n              // or a buggy LUT (LookUp Table):\n\n\n              p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\n              r = this.parseError(p.errStr, p, this.JisonParserError);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n              }\n\n              break;\n            // shift:\n\n            case 1:\n              stack[sp] = symbol;\n              vstack[sp] = lexer.yytext;\n              sstack[sp] = newState; // push state\n\n              ++sp;\n              symbol = 0; // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\n\n              continue;\n            // reduce:\n\n            case 2:\n              this_production = this.productions_[newState - 1]; // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\n\n              yyrulelen = this_production[1];\n              r = this.performAction.call(yyval, newState, sp - 1, vstack);\n\n              if (typeof r !== 'undefined') {\n                retval = r;\n                break;\n              } // pop off stack\n\n\n              sp -= yyrulelen; // don't overwrite the `symbol` variable: use a local var to speed things up:\n\n              var ntsymbol = this_production[0]; // push nonterminal (reduce)\n\n              stack[sp] = ntsymbol;\n              vstack[sp] = yyval.$; // goto new state = table[STATE][NONTERMINAL]\n\n              newState = table[sstack[sp - 1]][ntsymbol];\n              sstack[sp] = newState;\n              ++sp;\n              continue;\n            // accept:\n\n            case 3:\n              if (sp !== -2) {\n                retval = true; // Return the `$accept` rule's `$$` result, if available.\n                //\n                // Also note that JISON always adds this top-most `$accept` rule (with implicit,\n                // default, action):\n                //\n                //     $accept: <startSymbol> $end\n                //                  %{ $$ = $1; @$ = @1; %}\n                //\n                // which, combined with the parse kernel's `$accept` state behaviour coded below,\n                // will produce the `$$` value output of the <startSymbol> rule as the parse result,\n                // IFF that result is *not* `undefined`. (See also the parser kernel code.)\n                //\n                // In code:\n                //\n                //                  %{\n                //                      @$ = @1;            // if location tracking support is included\n                //                      if (typeof $1 !== 'undefined')\n                //                          return $1;\n                //                      else\n                //                          return true;           // the default parse result if the rule actions don't produce anything\n                //                  %}\n\n                sp--;\n\n                if (typeof vstack[sp] !== 'undefined') {\n                  retval = vstack[sp];\n                }\n              }\n\n              break;\n          } // break out of loop: we accept or fail with error\n\n\n          break;\n        }\n      } catch (ex) {\n        // report exceptions through the parseError callback too, but keep the exception intact\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\n        if (ex instanceof this.JisonParserError) {\n          throw ex;\n        } else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\n          throw ex;\n        }\n\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\n        retval = false;\n        r = this.parseError(p.errStr, p, this.JisonParserError);\n\n        if (typeof r !== 'undefined') {\n          retval = r;\n        }\n      } finally {\n        retval = this.cleanupAfterParse(retval, true, true);\n        this.__reentrant_call_depth--;\n      } // /finally\n\n\n      return retval;\n    }\n  };\n  parser.originalParseError = parser.parseError;\n  parser.originalQuoteName = parser.quoteName;\n  /* lexer generated by jison-lex 0.6.1-215 */\n\n  /*\r\n   * Returns a Lexer object of the following structure:\r\n   *\r\n   *  Lexer: {\r\n   *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n   *               the real \"shared state\" `yy` passed around to\r\n   *               the rule actions, etc. is a direct reference!\r\n   *\r\n   *               This \"shared context\" object was passed to the lexer by way of \r\n   *               the `lexer.setInput(str, yy)` API before you may use it.\r\n   *\r\n   *               This \"shared context\" object is passed to the lexer action code in `performAction()`\r\n   *               so userland code in the lexer actions may communicate with the outside world \r\n   *               and/or other lexer rules' actions in more or less complex ways.\r\n   *\r\n   *  }\r\n   *\r\n   *  Lexer.prototype: {\r\n   *    EOF: 1,\r\n   *    ERROR: 2,\r\n   *\r\n   *    yy:        The overall \"shared context\" object reference.\r\n   *\r\n   *    JisonLexerError: function(msg, hash),\r\n   *\r\n   *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\r\n   *\r\n   *               The function parameters and `this` have the following value/meaning:\r\n   *               - `this`    : reference to the `lexer` instance. \r\n   *                               `yy_` is an alias for `this` lexer instance reference used internally.\r\n   *\r\n   *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\r\n   *                             by way of the `lexer.setInput(str, yy)` API before.\r\n   *\r\n   *                             Note:\r\n   *                             The extra arguments you specified in the `%parse-param` statement in your\r\n   *                             **parser** grammar definition file are passed to the lexer via this object\r\n   *                             reference as member variables.\r\n   *\r\n   *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\r\n   *\r\n   *               - `YY_START`: the current lexer \"start condition\" state.\r\n   *\r\n   *    parseError: function(str, hash, ExceptionClass),\r\n   *\r\n   *    constructLexErrorInfo: function(error_message, is_recoverable),\r\n   *               Helper function.\r\n   *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n   *               See it's use in this lexer kernel in many places; example usage:\r\n   *\r\n   *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\r\n   *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\r\n   *\r\n   *    options: { ... lexer %options ... },\r\n   *\r\n   *    lex: function(),\r\n   *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\r\n   *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\r\n   *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n   *\r\n   *               WARNING:\r\n   *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\r\n   *               any attributes already added to `yy` by the **parser** or the jison run-time; \r\n   *               when such a collision is detected an exception is thrown to prevent the generated run-time \r\n   *               from silently accepting this confusing and potentially hazardous situation! \r\n   *\r\n   *    cleanupAfterLex: function(do_not_nuke_errorinfos),\r\n   *               Helper function.\r\n   *\r\n   *               This helper API is invoked when the **parse process** has completed: it is the responsibility\r\n   *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \r\n   *\r\n   *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\r\n   *\r\n   *    setInput: function(input, [yy]),\r\n   *\r\n   *\r\n   *    input: function(),\r\n   *\r\n   *\r\n   *    unput: function(str),\r\n   *\r\n   *\r\n   *    more: function(),\r\n   *\r\n   *\r\n   *    reject: function(),\r\n   *\r\n   *\r\n   *    less: function(n),\r\n   *\r\n   *\r\n   *    pastInput: function(n),\r\n   *\r\n   *\r\n   *    upcomingInput: function(n),\r\n   *\r\n   *\r\n   *    showPosition: function(),\r\n   *\r\n   *\r\n   *    test_match: function(regex_match_array, rule_index),\r\n   *\r\n   *\r\n   *    next: function(),\r\n   *\r\n   *\r\n   *    begin: function(condition),\r\n   *\r\n   *\r\n   *    pushState: function(condition),\r\n   *\r\n   *\r\n   *    popState: function(),\r\n   *\r\n   *\r\n   *    topState: function(),\r\n   *\r\n   *\r\n   *    _currentRules: function(),\r\n   *\r\n   *\r\n   *    stateStackSize: function(),\r\n   *\r\n   *\r\n   *    performAction: function(yy, yy_, yyrulenumber, YY_START),\r\n   *\r\n   *\r\n   *    rules: [...],\r\n   *\r\n   *\r\n   *    conditions: {associative list: name ==> set},\r\n   *  }\r\n   *\r\n   *\r\n   *  token location info (`yylloc`): {\r\n   *    first_line: n,\r\n   *    last_line: n,\r\n   *    first_column: n,\r\n   *    last_column: n,\r\n   *    range: [start_number, end_number]\r\n   *               (where the numbers are indexes into the input string, zero-based)\r\n   *  }\r\n   *\r\n   * ---\r\n   *\r\n   * The `parseError` function receives a 'hash' object with these members for lexer errors:\r\n   *\r\n   *  {\r\n   *    text:        (matched text)\r\n   *    token:       (the produced terminal token, if any)\r\n   *    token_id:    (the produced terminal token numeric ID, if any)\r\n   *    line:        (yylineno)\r\n   *    loc:         (yylloc)\r\n   *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n   *                  available for this particular error)\r\n   *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n   *                  as is also available in the rule actions; this can be used,\r\n   *                  for instance, for advanced error analysis and reporting)\r\n   *    lexer:       (reference to the current lexer instance used by the parser)\r\n   *  }\r\n   *\r\n   * while `this` will reference the current lexer instance.\r\n   *\r\n   * When `parseError` is invoked by the lexer, the default implementation will\r\n   * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\r\n   * it will try to invoke `yy.parseError()` instead. When that callback is also not\r\n   * provided, a `JisonLexerError` exception will be thrown containing the error\r\n   * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\r\n   *\r\n   * Note that the lexer's `JisonLexerError` error class is passed via the\r\n   * `ExceptionClass` argument, which is invoked to construct the exception\r\n   * instance to be thrown, so technically `parseError` will throw the object\r\n   * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\r\n   *\r\n   * ---\r\n   *\r\n   * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\r\n   * These options are available:\r\n   *\r\n   * (Options are permanent.)\r\n   *  \r\n   *  yy: {\r\n   *      parseError: function(str, hash, ExceptionClass)\r\n   *                 optional: overrides the default `parseError` function.\r\n   *  }\r\n   *\r\n   *  lexer.options: {\r\n   *      pre_lex:  function()\r\n   *                 optional: is invoked before the lexer is invoked to produce another token.\r\n   *                 `this` refers to the Lexer object.\r\n   *      post_lex: function(token) { return token; }\r\n   *                 optional: is invoked when the lexer has produced a token `token`;\r\n   *                 this function can override the returned token value by returning another.\r\n   *                 When it does not return any (truthy) value, the lexer will return\r\n   *                 the original `token`.\r\n   *                 `this` refers to the Lexer object.\r\n   *\r\n   * WARNING: the next set of options are not meant to be changed. They echo the abilities of\r\n   * the lexer as per when it was compiled!\r\n   *\r\n   *      ranges: boolean\r\n   *                 optional: `true` ==> token location info will include a .range[] member.\r\n   *      flex: boolean\r\n   *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n   *                 exhaustively to find the longest match.\r\n   *      backtrack_lexer: boolean\r\n   *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n   *                 the lexer terminates the scan when a token is returned by the action code.\r\n   *      xregexp: boolean\r\n   *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n   *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\r\n   *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n   *  }\r\n   */\n\n  var lexer = function () {\n    /**\r\n     * See also:\r\n     * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\r\n     * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\r\n     * with userland code which might access the derived class in a 'classic' way.\r\n     *\r\n     * @public\r\n     * @constructor\r\n     * @nocollapse\r\n     */\n    function JisonLexerError(msg, hash) {\n      Object.defineProperty(this, 'name', {\n        enumerable: false,\n        writable: false,\n        value: 'JisonLexerError'\n      });\n      if (msg == null) msg = '???';\n      Object.defineProperty(this, 'message', {\n        enumerable: false,\n        writable: true,\n        value: msg\n      });\n      this.hash = hash;\n      var stacktrace;\n\n      if (hash && hash.exception instanceof Error) {\n        var ex2 = hash.exception;\n        this.message = ex2.message || msg;\n        stacktrace = ex2.stack;\n      }\n\n      if (!stacktrace) {\n        if (Error.hasOwnProperty('captureStackTrace')) {\n          // V8\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          stacktrace = new Error(msg).stack;\n        }\n      }\n\n      if (stacktrace) {\n        Object.defineProperty(this, 'stack', {\n          enumerable: false,\n          writable: false,\n          value: stacktrace\n        });\n      }\n    }\n\n    if (typeof Object.setPrototypeOf === 'function') {\n      Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\n    } else {\n      JisonLexerError.prototype = Object.create(Error.prototype);\n    }\n\n    JisonLexerError.prototype.constructor = JisonLexerError;\n    JisonLexerError.prototype.name = 'JisonLexerError';\n    var lexer = {\n      // Code Generator Information Report\n      // ---------------------------------\n      //\n      // Options:\n      //\n      //   backtracking: .................... false\n      //   location.ranges: ................. false\n      //   location line+column tracking: ... true\n      //\n      //\n      // Forwarded Parser Analysis flags:\n      //\n      //   uses yyleng: ..................... false\n      //   uses yylineno: ................... false\n      //   uses yytext: ..................... false\n      //   uses yylloc: ..................... false\n      //   uses lexer values: ............... true / true\n      //   location tracking: ............... false\n      //   location assignment: ............. false\n      //\n      //\n      // Lexer Analysis flags:\n      //\n      //   uses yyleng: ..................... ???\n      //   uses yylineno: ................... ???\n      //   uses yytext: ..................... ???\n      //   uses yylloc: ..................... ???\n      //   uses ParseError API: ............. ???\n      //   uses yyerror: .................... ???\n      //   uses location tracking & editing:  ???\n      //   uses more() API: ................. ???\n      //   uses unput() API: ................ ???\n      //   uses reject() API: ............... ???\n      //   uses less() API: ................. ???\n      //   uses display APIs pastInput(), upcomingInput(), showPosition():\n      //        ............................. ???\n      //   uses describeYYLLOC() API: ....... ???\n      //\n      // --------- END OF REPORT -----------\n      EOF: 1,\n      ERROR: 2,\n      // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\n      // options: {},                             /// <-- injected by the code generator\n      // yy: ...,                                 /// <-- injected by setInput()\n      __currentRuleSet__: null,\n      /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  \n      __error_infos: [],\n      /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  \n      __decompressed: false,\n      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  \n      done: false,\n      /// INTERNAL USE ONLY  \n      _backtrack: false,\n      /// INTERNAL USE ONLY  \n      _input: '',\n      /// INTERNAL USE ONLY  \n      _more: false,\n      /// INTERNAL USE ONLY  \n      _signaled_error_token: false,\n      /// INTERNAL USE ONLY  \n      conditionStack: [],\n      /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  \n      match: '',\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  \n      matched: '',\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  \n      matches: false,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  \n      yytext: '',\n      /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  \n      offset: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  \n      yyleng: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  \n      yylineno: 0,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  \n      yylloc: null,\n      /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  \n\n      /**\r\n       * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\n        msg = '' + msg; // heuristic to determine if the error message already contains a (partial) source code dump\n        // as produced by either `showPosition()` or `prettyPrintRange()`:\n\n        if (show_input_position == undefined) {\n          show_input_position = !(msg.indexOf('\\n') > 0 && msg.indexOf('^') > 0);\n        }\n\n        if (this.yylloc && show_input_position) {\n          if (typeof this.prettyPrintRange === 'function') {\n            var pretty_src = this.prettyPrintRange(this.yylloc);\n\n            if (!/\\n\\s*$/.test(msg)) {\n              msg += '\\n';\n            }\n\n            msg += '\\n  Erroneous area:\\n' + this.prettyPrintRange(this.yylloc);\n          } else if (typeof this.showPosition === 'function') {\n            var pos_str = this.showPosition();\n\n            if (pos_str) {\n              if (msg.length && msg[msg.length - 1] !== '\\n' && pos_str[0] !== '\\n') {\n                msg += '\\n' + pos_str;\n              } else {\n                msg += pos_str;\n              }\n            }\n          }\n        }\n        /** @constructor */\n\n\n        var pei = {\n          errStr: msg,\n          recoverable: !!recoverable,\n          text: this.match,\n          // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  \n          token: null,\n          line: this.yylineno,\n          loc: this.yylloc,\n          yy: this.yy,\n          lexer: this,\n\n          /**\r\n           * and make sure the error info doesn't stay due to potential\r\n           * ref cycle via userland code manipulations.\r\n           * These would otherwise all be memory leak opportunities!\r\n           * \r\n           * Note that only array and object references are nuked as those\r\n           * constitute the set of elements which can produce a cyclic ref.\r\n           * The rest of the members is kept intact as they are harmless.\r\n           * \r\n           * @public\r\n           * @this {LexErrorInfo}\r\n           */\n          destroy: function destructLexErrorInfo() {\n            // remove cyclic references added to error info:\n            // info.yy = null;\n            // info.lexer = null;\n            // ...\n            var rec = !!this.recoverable;\n\n            for (var key in this) {\n              if (this.hasOwnProperty(key) && typeof key === 'object') {\n                this[key] = undefined;\n              }\n            }\n\n            this.recoverable = rec;\n          }\n        }; // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\n\n        this.__error_infos.push(pei);\n\n        return pei;\n      },\n\n      /**\r\n       * handler which is invoked when a lexer error occurs.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      parseError: function lexer_parseError(str, hash, ExceptionClass) {\n        if (!ExceptionClass) {\n          ExceptionClass = this.JisonLexerError;\n        }\n\n        if (this.yy) {\n          if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {\n            return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n          } else if (typeof this.yy.parseError === 'function') {\n            return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\n          }\n        }\n\n        throw new ExceptionClass(str, hash);\n      },\n\n      /**\r\n       * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      yyerror: function yyError(str\n      /*, ...args */\n      ) {\n        var lineno_msg = '';\n\n        if (this.yylloc) {\n          lineno_msg = ' on line ' + (this.yylineno + 1);\n        }\n\n        var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': ' + str, this.options.lexerErrorsAreRecoverable); // Add any extra args to the hash under the name `extra_error_attributes`:\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if (args.length) {\n          p.extra_error_attributes = args;\n        }\n\n        return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n      },\n\n      /**\r\n       * final cleanup function for when we have completed lexing the input;\r\n       * make it an API so that external code can use this one once userland\r\n       * code has decided it's time to destroy any lingering lexer error\r\n       * hash object instances and the like: this function helps to clean\r\n       * up these constructs, which *may* carry cyclic references which would\r\n       * otherwise prevent the instances from being properly and timely\r\n       * garbage-collected, i.e. this function helps prevent memory leaks!\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\n        // prevent lingering circular references from causing memory leaks:\n        this.setInput('', {}); // nuke the error hash info instances created during this run.\n        // Userland code must COPY any data/references\n        // in the error hash instance(s) it is more permanently interested in.\n\n        if (!do_not_nuke_errorinfos) {\n          for (var i = this.__error_infos.length - 1; i >= 0; i--) {\n            var el = this.__error_infos[i];\n\n            if (el && typeof el.destroy === 'function') {\n              el.destroy();\n            }\n          }\n\n          this.__error_infos.length = 0;\n        }\n\n        return this;\n      },\n\n      /**\r\n       * clear the lexer token context; intended for internal use only\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      clear: function lexer_clear() {\n        this.yytext = '';\n        this.yyleng = 0;\n        this.match = ''; // - DO NOT reset `this.matched`\n\n        this.matches = false;\n        this._more = false;\n        this._backtrack = false;\n        var col = this.yylloc ? this.yylloc.last_column : 0;\n        this.yylloc = {\n          first_line: this.yylineno + 1,\n          first_column: col,\n          last_line: this.yylineno + 1,\n          last_column: col,\n          range: [this.offset, this.offset]\n        };\n      },\n\n      /**\r\n       * resets the lexer, sets new input\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      setInput: function lexer_setInput(input, yy) {\n        this.yy = yy || this.yy || {}; // also check if we've fully initialized the lexer instance,\n        // including expansion work to be done to go from a loaded\n        // lexer to a usable lexer:\n\n        if (!this.__decompressed) {\n          // step 1: decompress the regex list:\n          var rules = this.rules;\n\n          for (var i = 0, len = rules.length; i < len; i++) {\n            var rule_re = rules[i]; // compression: is the RE an xref to another RE slot in the rules[] table?\n\n            if (typeof rule_re === 'number') {\n              rules[i] = rules[rule_re];\n            }\n          } // step 2: unfold the conditions[] set to make these ready for use:\n\n\n          var conditions = this.conditions;\n\n          for (var k in conditions) {\n            var spec = conditions[k];\n            var rule_ids = spec.rules;\n            var len = rule_ids.length;\n            var rule_regexes = new Array(len + 1); // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! \n\n            var rule_new_ids = new Array(len + 1);\n\n            for (var i = 0; i < len; i++) {\n              var idx = rule_ids[i];\n              var rule_re = rules[idx];\n              rule_regexes[i + 1] = rule_re;\n              rule_new_ids[i + 1] = idx;\n            }\n\n            spec.rules = rule_new_ids;\n            spec.__rule_regexes = rule_regexes;\n            spec.__rule_count = len;\n          }\n\n          this.__decompressed = true;\n        }\n\n        this._input = input || '';\n        this.clear();\n        this._signaled_error_token = false;\n        this.done = false;\n        this.yylineno = 0;\n        this.matched = '';\n        this.conditionStack = ['INITIAL'];\n        this.__currentRuleSet__ = null;\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0,\n          range: [0, 0]\n        };\n        this.offset = 0;\n        return this;\n      },\n\n      /**\r\n       * edit the remaining input via user-specified callback.\r\n       * This can be used to forward-adjust the input-to-parse, \r\n       * e.g. inserting macro expansions and alike in the\r\n       * input which has yet to be lexed.\r\n       * The behaviour of this API contrasts the `unput()` et al\r\n       * APIs as those act on the *consumed* input, while this\r\n       * one allows one to manipulate the future, without impacting\r\n       * the current `yyloc` cursor location or any history. \r\n       * \r\n       * Use this API to help implement C-preprocessor-like\r\n       * `#include` statements, etc.\r\n       * \r\n       * The provided callback must be synchronous and is\r\n       * expected to return the edited input (string).\r\n       *\r\n       * The `cpsArg` argument value is passed to the callback\r\n       * as-is.\r\n       *\r\n       * `callback` interface: \r\n       * `function callback(input, cpsArg)`\r\n       * \r\n       * - `input` will carry the remaining-input-to-lex string\r\n       *   from the lexer.\r\n       * - `cpsArg` is `cpsArg` passed into this API.\r\n       * \r\n       * The `this` reference for the callback will be set to\r\n       * reference this lexer instance so that userland code\r\n       * in the callback can easily and quickly access any lexer\r\n       * API. \r\n       *\r\n       * When the callback returns a non-string-type falsey value,\r\n       * we assume the callback did not edit the input and we\r\n       * will using the input as-is.\r\n       *\r\n       * When the callback returns a non-string-type value, it\r\n       * is converted to a string for lexing via the `\"\" + retval`\r\n       * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \r\n       * -- that way any returned object's `toValue()` and `toString()`\r\n       * methods will be invoked in a proper/desirable order.)\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\n        var rv = callback.call(this, this._input, cpsArg);\n\n        if (typeof rv !== 'string') {\n          if (rv) {\n            this._input = '' + rv;\n          } // else: keep `this._input` as is.  \n\n        } else {\n          this._input = rv;\n        }\n\n        return this;\n      },\n\n      /**\r\n       * consumes and returns one char from the input\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      input: function lexer_input() {\n        if (!this._input) {\n          //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\n          return null;\n        }\n\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch; // Count the linenumber up when we hit the LF (or a stand-alone CR).\n        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\n        // and we advance immediately past the LF as well, returning both together as if\n        // it was all a single 'character' only.\n\n        var slice_len = 1;\n        var lines = false;\n\n        if (ch === '\\n') {\n          lines = true;\n        } else if (ch === '\\r') {\n          lines = true;\n          var ch2 = this._input[1];\n\n          if (ch2 === '\\n') {\n            slice_len++;\n            ch += ch2;\n            this.yytext += ch2;\n            this.yyleng++;\n            this.offset++;\n            this.match += ch2;\n            this.matched += ch2;\n            this.yylloc.range[1]++;\n          }\n        }\n\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n        } else {\n          this.yylloc.last_column++;\n        }\n\n        this.yylloc.range[1]++;\n        this._input = this._input.slice(slice_len);\n        return ch;\n      },\n\n      /**\r\n       * unshifts one char (or an entire string) into the input\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      unput: function lexer_unput(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.yyleng = this.yytext.length;\n        this.offset -= len;\n        this.match = this.match.substr(0, this.match.length - len);\n        this.matched = this.matched.substr(0, this.matched.length - len);\n\n        if (lines.length > 1) {\n          this.yylineno -= lines.length - 1;\n          this.yylloc.last_line = this.yylineno + 1; // Get last entirely matched line into the `pre_lines[]` array's\n          // last index slot; we don't mind when other previously \n          // matched lines end up in the array too. \n\n          var pre = this.match;\n          var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n\n          if (pre_lines.length === 1) {\n            pre = this.matched;\n            pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\n          }\n\n          this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\n        } else {\n          this.yylloc.last_column -= len;\n        }\n\n        this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\n        this.done = false;\n        return this;\n      },\n\n      /**\r\n       * cache matched text and append it on next action\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      more: function lexer_more() {\n        this._more = true;\n        return this;\n      },\n\n      /**\r\n       * signal the lexer that this rule fails to match the input, so the\r\n       * next matching rule (regex) should be tested instead.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      reject: function lexer_reject() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          // when the `parseError()` call returns, we MUST ensure that the error is registered.\n          // We accomplish this by signaling an 'error' token to be produced for the current\n          // `.lex()` run.\n          var lineno_msg = '';\n\n          if (this.yylloc) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).', false);\n          this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n        }\n\n        return this;\n      },\n\n      /**\r\n       * retain first n characters of the match\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      less: function lexer_less(n) {\n        return this.unput(this.match.slice(n));\n      },\n\n      /**\r\n       * return (part of the) already matched input, i.e. for error\r\n       * messages.\r\n       * \r\n       * Limit the returned string length to `maxSize` (default: 20).\r\n       * \r\n       * Limit the returned string to the `maxLines` number of lines of\r\n       * input (default: 1).\r\n       * \r\n       * Negative limit values equal *unlimited*.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      pastInput: function lexer_pastInput(maxSize, maxLines) {\n        var past = this.matched.substring(0, this.matched.length - this.match.length);\n        if (maxSize < 0) maxSize = past.length;else if (!maxSize) maxSize = 20;\n        if (maxLines < 0) maxLines = past.length; // can't ever have more input lines than this! \n        else if (!maxLines) maxLines = 1; // `substr` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we've transformed and limited the newLines in here:\n\n        past = past.substr(-maxSize * 2 - 2); // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n\n        var a = past.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n        a = a.slice(-maxLines);\n        past = a.join('\\n'); // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis prefix...\n\n        if (past.length > maxSize) {\n          past = '...' + past.substr(-maxSize);\n        }\n\n        return past;\n      },\n\n      /**\r\n       * return (part of the) upcoming input, i.e. for error messages.\r\n       * \r\n       * Limit the returned string length to `maxSize` (default: 20).\r\n       * \r\n       * Limit the returned string to the `maxLines` number of lines of input (default: 1).\r\n       * \r\n       * Negative limit values equal *unlimited*.\r\n       *\r\n       * > ### NOTE ###\r\n       * >\r\n       * > *\"upcoming input\"* is defined as the whole of the both\r\n       * > the *currently lexed* input, together with any remaining input\r\n       * > following that. *\"currently lexed\"* input is the input \r\n       * > already recognized by the lexer but not yet returned with\r\n       * > the lexer token. This happens when you are invoking this API\r\n       * > from inside any lexer rule action code block. \r\n       * >\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\n        var next = this.match;\n        if (maxSize < 0) maxSize = next.length + this._input.length;else if (!maxSize) maxSize = 20;\n        if (maxLines < 0) maxLines = maxSize; // can't ever have more input lines than this! \n        else if (!maxLines) maxLines = 1; // `substring` anticipation: treat \\r\\n as a single character and take a little\n        // more than necessary so that we can still properly check against maxSize\n        // after we've transformed and limited the newLines in here:\n\n        if (next.length < maxSize * 2 + 2) {\n          next += this._input.substring(0, maxSize * 2 + 2); // substring is faster on Chrome/V8 \n        } // now that we have a significantly reduced string to process, transform the newlines\n        // and chop them, then limit them:\n\n\n        var a = next.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\n        a = a.slice(0, maxLines);\n        next = a.join('\\n'); // When, after limiting to maxLines, we still have too much to return,\n        // do add an ellipsis postfix...\n\n        if (next.length > maxSize) {\n          next = next.substring(0, maxSize) + '...';\n        }\n\n        return next;\n      },\n\n      /**\r\n       * return a string which displays the character position where the\r\n       * lexing error occurred, i.e. for error messages\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\n        var pre = this.pastInput(maxPrefix).replace(/\\s/g, ' ');\n        var c = new Array(pre.length + 1).join('-');\n        return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, ' ') + '\\n' + c + '^';\n      },\n\n      /**\r\n       * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\r\n       * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\r\n       * it MAY be NULL) and you MUST have a valid location info object anyway:\r\n       * then we take the given context of the `preceding` and `following` locations, IFF those are available,\r\n       * and reconstruct the `actual` location info from those.\r\n       * If this fails, the heuristic is to take the `current` location, IFF available.\r\n       * If this fails as well, we assume the sought location is at/around the current lexer position\r\n       * and then produce that one as a response. DO NOTE that these heuristic/derived location info\r\n       * values MAY be inaccurate!\r\n       *\r\n       * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\r\n       * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\n        var loc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0,\n          range: [0, 0]\n        };\n\n        if (actual) {\n          loc.first_line = actual.first_line | 0;\n          loc.last_line = actual.last_line | 0;\n          loc.first_column = actual.first_column | 0;\n          loc.last_column = actual.last_column | 0;\n\n          if (actual.range) {\n            loc.range[0] = actual.range[0] | 0;\n            loc.range[1] = actual.range[1] | 0;\n          }\n        }\n\n        if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\n          // plan B: heuristic using preceding and following:\n          if (loc.first_line <= 0 && preceding) {\n            loc.first_line = preceding.last_line | 0;\n            loc.first_column = preceding.last_column | 0;\n\n            if (preceding.range) {\n              loc.range[0] = actual.range[1] | 0;\n            }\n          }\n\n          if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\n            loc.last_line = following.first_line | 0;\n            loc.last_column = following.first_column | 0;\n\n            if (following.range) {\n              loc.range[1] = actual.range[0] | 0;\n            }\n          } // plan C?: see if the 'current' location is useful/sane too:\n\n\n          if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\n            loc.first_line = current.first_line | 0;\n            loc.first_column = current.first_column | 0;\n\n            if (current.range) {\n              loc.range[0] = current.range[0] | 0;\n            }\n          }\n\n          if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\n            loc.last_line = current.last_line | 0;\n            loc.last_column = current.last_column | 0;\n\n            if (current.range) {\n              loc.range[1] = current.range[1] | 0;\n            }\n          }\n        } // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\n        // or plan D heuristics to produce a 'sensible' last_line value:\n\n\n        if (loc.last_line <= 0) {\n          if (loc.first_line <= 0) {\n            loc.first_line = this.yylloc.first_line;\n            loc.last_line = this.yylloc.last_line;\n            loc.first_column = this.yylloc.first_column;\n            loc.last_column = this.yylloc.last_column;\n            loc.range[0] = this.yylloc.range[0];\n            loc.range[1] = this.yylloc.range[1];\n          } else {\n            loc.last_line = this.yylloc.last_line;\n            loc.last_column = this.yylloc.last_column;\n            loc.range[1] = this.yylloc.range[1];\n          }\n        }\n\n        if (loc.first_line <= 0) {\n          loc.first_line = loc.last_line;\n          loc.first_column = 0; // loc.last_column; \n\n          loc.range[1] = loc.range[0];\n        }\n\n        if (loc.first_column < 0) {\n          loc.first_column = 0;\n        }\n\n        if (loc.last_column < 0) {\n          loc.last_column = loc.first_column > 0 ? loc.first_column : 80;\n        }\n\n        return loc;\n      },\n\n      /**\r\n       * return a string which displays the lines & columns of input which are referenced \r\n       * by the given location info range, plus a few lines of context.\r\n       * \r\n       * This function pretty-prints the indicated section of the input, with line numbers \r\n       * and everything!\r\n       * \r\n       * This function is very useful to provide highly readable error reports, while\r\n       * the location range may be specified in various flexible ways:\r\n       * \r\n       * - `loc` is the location info object which references the area which should be\r\n       *   displayed and 'marked up': these lines & columns of text are marked up by `^`\r\n       *   characters below each character in the entire input range.\r\n       * \r\n       * - `context_loc` is the *optional* location info object which instructs this\r\n       *   pretty-printer how much *leading* context should be displayed alongside\r\n       *   the area referenced by `loc`. This can help provide context for the displayed\r\n       *   error, etc.\r\n       * \r\n       *   When this location info is not provided, a default context of 3 lines is\r\n       *   used.\r\n       * \r\n       * - `context_loc2` is another *optional* location info object, which serves\r\n       *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\r\n       *   context lines to display in the pretty-print output.\r\n       * \r\n       *   When this location info is not provided, a default context of 1 line only is\r\n       *   used.\r\n       * \r\n       * Special Notes:\r\n       * \r\n       * - when the `loc`-indicated range is very large (about 5 lines or more), then\r\n       *   only the first and last few lines of this block are printed while a\r\n       *   `...continued...` message will be printed between them.\r\n       * \r\n       *   This serves the purpose of not printing a huge amount of text when the `loc`\r\n       *   range happens to be huge: this way a manageable & readable output results\r\n       *   for arbitrary large ranges.\r\n       * \r\n       * - this function can display lines of input which whave not yet been lexed.\r\n       *   `prettyPrintRange()` can access the entire input!\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\n        loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\n        const CONTEXT = 3;\n        const CONTEXT_TAIL = 1;\n        const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\n        var input = this.matched + this._input;\n        var lines = input.split('\\n');\n        var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);\n        var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);\n        var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\n        var ws_prefix = new Array(lineno_display_width).join(' ');\n        var nonempty_line_indexes = [];\n        var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\n          var lno = index + l0;\n          var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\n          var rv = lno_pfx + ': ' + line;\n          var errpfx = new Array(lineno_display_width + 1).join('^');\n          var offset = 2 + 1;\n          var len = 0;\n\n          if (lno === loc.first_line) {\n            offset += loc.first_column;\n            len = Math.max(2, (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1);\n          } else if (lno === loc.last_line) {\n            len = Math.max(2, loc.last_column + 1);\n          } else if (lno > loc.first_line && lno < loc.last_line) {\n            len = Math.max(2, line.length + 1);\n          }\n\n          if (len) {\n            var lead = new Array(offset).join('.');\n            var mark = new Array(len).join('^');\n            rv += '\\n' + errpfx + lead + mark;\n\n            if (line.trim().length > 0) {\n              nonempty_line_indexes.push(index);\n            }\n          }\n\n          rv = rv.replace(/\\t/g, ' ');\n          return rv;\n        }); // now make sure we don't print an overly large amount of error area: limit it \n        // to the top and bottom line count:\n\n        if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\n          var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\n          var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\n          var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';\n          intermediate_line += '\\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';\n          rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\n        }\n\n        return rv.join('\\n');\n      },\n\n      /**\r\n       * helper function, used to produce a human readable description as a string, given\r\n       * the input `yylloc` location object.\r\n       * \r\n       * Set `display_range_too` to TRUE to include the string character index position(s)\r\n       * in the description if the `yylloc.range` is available.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\n        var l1 = yylloc.first_line;\n        var l2 = yylloc.last_line;\n        var c1 = yylloc.first_column;\n        var c2 = yylloc.last_column;\n        var dl = l2 - l1;\n        var dc = c2 - c1;\n        var rv;\n\n        if (dl === 0) {\n          rv = 'line ' + l1 + ', ';\n\n          if (dc <= 1) {\n            rv += 'column ' + c1;\n          } else {\n            rv += 'columns ' + c1 + ' .. ' + c2;\n          }\n        } else {\n          rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';\n        }\n\n        if (yylloc.range && display_range_too) {\n          var r1 = yylloc.range[0];\n          var r2 = yylloc.range[1] - 1;\n\n          if (r2 <= r1) {\n            rv += ' {String Offset: ' + r1 + '}';\n          } else {\n            rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';\n          }\n        }\n\n        return rv;\n      },\n\n      /**\r\n       * test the lexed token: return FALSE when not a match, otherwise return token.\r\n       * \r\n       * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\r\n       * contains the actually matched text string.\r\n       * \r\n       * Also move the input cursor forward and update the match collectors:\r\n       * \r\n       * - `yytext`\r\n       * - `yyleng`\r\n       * - `match`\r\n       * - `matches`\r\n       * - `yylloc`\r\n       * - `offset`\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      test_match: function lexer_test_match(match, indexed_rule) {\n        var token, lines, backup, match_str, match_str_len;\n\n        if (this.options.backtrack_lexer) {\n          // save context\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.yylloc.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column,\n              range: this.yylloc.range.slice(0)\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            //_signaled_error_token: this._signaled_error_token,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n        }\n\n        match_str = match[0];\n        match_str_len = match_str.length; // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\n\n        lines = match_str.split(/(?:\\r\\n?|\\n)/g);\n\n        if (lines.length > 1) {\n          this.yylineno += lines.length - 1;\n          this.yylloc.last_line = this.yylineno + 1;\n          this.yylloc.last_column = lines[lines.length - 1].length;\n        } else {\n          this.yylloc.last_column += match_str_len;\n        } // }\n\n\n        this.yytext += match_str;\n        this.match += match_str;\n        this.matched += match_str;\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        this.yylloc.range[1] += match_str_len; // previous lex rules MAY have invoked the `more()` API rather than producing a token:\n        // those rules will already have moved this `offset` forward matching their match lengths,\n        // hence we must only add our own match length now:\n\n        this.offset += match_str_len;\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match_str_len); // calling this method:\n        //\n        //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\n\n        token = this.performAction.call(this, this.yy, indexed_rule, this.conditionStack[this.conditionStack.length - 1]\n        /* = YY_START */\n        ); // otherwise, when the action codes are all simple return token statements:\n        //token = this.simpleCaseActionClusters[indexed_rule];\n\n        if (this.done && this._input) {\n          this.done = false;\n        }\n\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          // recover context\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n\n          this.__currentRuleSet__ = null;\n          return false; // rule action called reject() implying the next rule should be tested instead. \n        } else if (this._signaled_error_token) {\n          // produce one 'error' token as `.parseError()` in `reject()`\n          // did not guarantee a failure signal by throwing an exception!\n          token = this._signaled_error_token;\n          this._signaled_error_token = false;\n          return token;\n        }\n\n        return false;\n      },\n\n      /**\r\n       * return next match in input\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      next: function lexer_next() {\n        if (this.done) {\n          this.clear();\n          return this.EOF;\n        }\n\n        if (!this._input) {\n          this.done = true;\n        }\n\n        var token, match, tempMatch, index;\n\n        if (!this._more) {\n          this.clear();\n        }\n\n        var spec = this.__currentRuleSet__;\n\n        if (!spec) {\n          // Update the ruleset cache as we apparently encountered a state change or just started lexing.\n          // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\n          // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\n          // speed up those activities a tiny bit.\n          spec = this.__currentRuleSet__ = this._currentRules(); // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\n          // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\n\n          if (!spec || !spec.rules) {\n            var lineno_msg = '';\n\n            if (this.options.trackPosition) {\n              lineno_msg = ' on line ' + (this.yylineno + 1);\n            }\n\n            var p = this.constructLexErrorInfo('Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!', false); // produce one 'error' token until this situation has been resolved, most probably by parse termination!\n\n            return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n          }\n        }\n\n        var rule_ids = spec.rules;\n        var regexes = spec.__rule_regexes;\n        var len = spec.__rule_count; // Note: the arrays are 1-based, while `len` itself is a valid index,\n        // hence the non-standard less-or-equal check in the next loop condition!\n\n        for (var i = 1; i <= len; i++) {\n          tempMatch = this._input.match(regexes[i]);\n\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rule_ids[i]);\n\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = undefined;\n                continue; // rule action called reject() implying a rule MISmatch. \n              } else {\n                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n\n        if (match) {\n          token = this.test_match(match, rule_ids[index]);\n\n          if (token !== false) {\n            return token;\n          } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n          return false;\n        }\n\n        if (!this._input) {\n          this.done = true;\n          this.clear();\n          return this.EOF;\n        } else {\n          var lineno_msg = '';\n\n          if (this.options.trackPosition) {\n            lineno_msg = ' on line ' + (this.yylineno + 1);\n          }\n\n          var p = this.constructLexErrorInfo('Lexical error' + lineno_msg + ': Unrecognized text.', this.options.lexerErrorsAreRecoverable);\n          var pendingInput = this._input;\n          var activeCondition = this.topState();\n          var conditionStackDepth = this.conditionStack.length;\n          token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\n\n          if (token === this.ERROR) {\n            // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\n            // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\n            // has not consumed/modified any pending input or changed state in the error handler:\n            if (!this.matches && // and make sure the input has been modified/consumed ...\n            pendingInput === this._input && // ...or the lexer state has been modified significantly enough\n            // to merit a non-consuming error handling action right now.\n            activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\n              this.input();\n            }\n          }\n\n          return token;\n        }\n      },\n\n      /**\r\n       * return next match that has a token\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      lex: function lexer_lex() {\n        var r; // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\n\n        if (typeof this.pre_lex === 'function') {\n          r = this.pre_lex.call(this, 0);\n        }\n\n        if (typeof this.options.pre_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.options.pre_lex.call(this, r) || r;\n        }\n\n        if (this.yy && typeof this.yy.pre_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.yy.pre_lex.call(this, r) || r;\n        }\n\n        while (!r) {\n          r = this.next();\n        }\n\n        if (this.yy && typeof this.yy.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.yy.post_lex.call(this, r) || r;\n        }\n\n        if (typeof this.options.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.options.post_lex.call(this, r) || r;\n        }\n\n        if (typeof this.post_lex === 'function') {\n          // (also account for a userdef function which does not return any value: keep the token as is)\n          r = this.post_lex.call(this, r) || r;\n        }\n\n        return r;\n      },\n\n      /**\r\n       * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \r\n       * `pre_lex()` nor any of the `post_lex()` callbacks.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      fastLex: function lexer_fastLex() {\n        var r;\n\n        while (!r) {\n          r = this.next();\n        }\n\n        return r;\n      },\n\n      /**\r\n       * return info about the lexer state that can help a parser or other lexer API user to use the\r\n       * most efficient means available. This API is provided to aid run-time performance for larger\r\n       * systems which employ this lexer.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      canIUse: function lexer_canIUse() {\n        var rv = {\n          fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'\n        };\n        return rv;\n      },\n\n      /**\r\n       * backwards compatible alias for `pushState()`;\r\n       * the latter is symmetrical with `popState()` and we advise to use\r\n       * those APIs in any modern lexer code, rather than `begin()`.\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      begin: function lexer_begin(condition) {\n        return this.pushState(condition);\n      },\n\n      /**\r\n       * activates a new lexer condition state (pushes the new lexer\r\n       * condition state onto the condition stack)\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      pushState: function lexer_pushState(condition) {\n        this.conditionStack.push(condition);\n        this.__currentRuleSet__ = null;\n        return this;\n      },\n\n      /**\r\n       * pop the previously active lexer condition state off the condition\r\n       * stack\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      popState: function lexer_popState() {\n        var n = this.conditionStack.length - 1;\n\n        if (n > 0) {\n          this.__currentRuleSet__ = null;\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      },\n\n      /**\r\n       * return the currently active lexer condition state; when an index\r\n       * argument is provided it produces the N-th previous condition state,\r\n       * if available\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      topState: function lexer_topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return 'INITIAL';\n        }\n      },\n\n      /**\r\n       * (internal) determine the lexer rule set which is active for the\r\n       * currently active lexer condition state\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      _currentRules: function lexer__currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\n        } else {\n          return this.conditions['INITIAL'];\n        }\n      },\n\n      /**\r\n       * return the number of states currently on the stack\r\n       * \r\n       * @public\r\n       * @this {RegExpLexer}\r\n       */\n      stateStackSize: function lexer_stateStackSize() {\n        return this.conditionStack.length;\n      },\n      options: {\n        trackPosition: true\n      },\n      JisonLexerError: JisonLexerError,\n      performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\n        var yy_ = this;\n        var YYSTATE = YY_START;\n\n        switch (yyrulenumber) {\n          case 1:\n            /*! Conditions:: INITIAL */\n\n            /*! Rule::       \\s+ */\n\n            /* skip whitespace */\n            break;\n\n          default:\n            return this.simpleCaseActionClusters[yyrulenumber];\n        }\n      },\n      simpleCaseActionClusters: {\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       (--[0-9a-z-A-Z-]*) */\n        0: 13,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\* */\n        2: 5,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\/ */\n        3: 6,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\+ */\n        4: 3,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       - */\n        5: 4,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */\n        6: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */\n        7: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */\n        8: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */\n        9: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */\n        10: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */\n        11: 15,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */\n        12: 16,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */\n        13: 16,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */\n        14: 16,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */\n        15: 16,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */\n        16: 17,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */\n        17: 17,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */\n        18: 18,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */\n        19: 18,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */\n        20: 19,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */\n        21: 19,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */\n        22: 19,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */\n        23: 20,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */\n        24: 21,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */\n        25: 22,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */\n        26: 23,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */\n        27: 25,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */\n        28: 24,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */\n        29: 26,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */\n        30: 27,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */\n        31: 28,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */\n        32: 11,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       (calc) */\n        33: 9,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       (var) */\n        34: 12,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       ([a-z]+) */\n        35: 10,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\( */\n        36: 7,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       \\) */\n        37: 8,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       , */\n        38: 14,\n\n        /*! Conditions:: INITIAL */\n\n        /*! Rule::       $ */\n        39: 1\n      },\n      rules: [\n      /*  0: */\n      /^(?:(--[\\d\\-A-Za-z]*))/,\n      /*  1: */\n      /^(?:\\s+)/,\n      /*  2: */\n      /^(?:\\*)/,\n      /*  3: */\n      /^(?:\\/)/,\n      /*  4: */\n      /^(?:\\+)/,\n      /*  5: */\n      /^(?:-)/,\n      /*  6: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\n      /*  7: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\n      /*  8: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\n      /*  9: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\n      /* 10: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\n      /* 11: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\n      /* 12: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\n      /* 13: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\n      /* 14: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\n      /* 15: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\n      /* 16: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\n      /* 17: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\n      /* 18: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\n      /* 19: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\n      /* 20: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\n      /* 21: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\n      /* 22: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\n      /* 23: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\n      /* 24: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\n      /* 25: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\n      /* 26: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\n      /* 27: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\n      /* 28: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\n      /* 29: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\n      /* 30: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\n      /* 31: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\n      /* 32: */\n      /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\n      /* 33: */\n      /^(?:(calc))/,\n      /* 34: */\n      /^(?:(var))/,\n      /* 35: */\n      /^(?:([a-z]+))/,\n      /* 36: */\n      /^(?:\\()/,\n      /* 37: */\n      /^(?:\\))/,\n      /* 38: */\n      /^(?:,)/,\n      /* 39: */\n      /^(?:$)/],\n      conditions: {\n        'INITIAL': {\n          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n          inclusive: true\n        }\n      }\n    };\n    return lexer;\n  }();\n\n  parser.lexer = lexer;\n\n  function Parser() {\n    this.yy = {};\n  }\n\n  Parser.prototype = parser;\n  parser.Parser = Parser;\n  return new Parser();\n}();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  exports.parser = parser;\n  exports.Parser = parser.Parser;\n\n  exports.parse = function () {\n    return parser.parse.apply(parser, arguments);\n  };\n}","map":{"version":3,"names":["parser","JisonParserError","msg","hash","Object","defineProperty","enumerable","writable","value","stacktrace","exception","Error","ex2","message","stack","hasOwnProperty","captureStackTrace","constructor","setPrototypeOf","prototype","create","name","bp","s","rv","p","pop","r","rule","i","l","length","push","bda","d","idx","g","goto","j","bt","len","y","symbol","t","type","a","state","m","mode","n","q","z","shift","c","u","e","apply","trace","no_op_trace","yy","options","hasPartialLrUpgradeOnConflict","errorRecoveryTokenDiscardCount","symbols_","terminals_","TERROR","EOF","originalQuoteName","originalParseError","cleanupAfterParse","constructParseErrorInfo","yyMergeLocationInfo","__reentrant_call_depth","__error_infos","__error_recovery_infos","quoteName","parser_quoteName","id_str","getSymbolName","parser_getSymbolName","key","describeSymbol","parser_describeSymbol","terminal_descriptions_","id","collect_expected_token_set","parser_collect_expected_token_set","do_not_describe","tokenset","check","state_descriptions_","table","productions_","performAction","parser__PerformAction","yystate","yysp","yyvstack","yyparser","yylexer","lexer","$","operator","left","right","prefix","parseFloat","fallback","unit","exec","prev","defaultActions","parseError","str","ExceptionClass","recoverable","destroy","parse","input","self","Array","sstack","vstack","sp","ERROR_RECOVERY_TOKEN_DISCARD_COUNT","NO_ACTION","__lexer__","sharedState_yy","undefined","pre_parse","post_parse","pre_lex","post_lex","ASSERT","assert","JisonAssert","cond","yyGetSharedState","shallow_copy_noclobber","dst","src","k","call","parseErrorAlt","quoteNameAlt","parser_cleanupAfterParse","resultValue","invoke_post_methods","do_not_nuke_errorinfos","cleanupAfterLex","el","parser_constructParseErrorInfo","ex","expected","pei","errStr","text","match","yytext","token","token_id","line","yylineno","action","new_state","newState","symbol_stack","state_stack","value_stack","stack_pointer","destructParseErrorInfo","rec","getNonTerminalFromCode","tokenName","stdLex","lex","fastLex","yyval","_$","yyrulelen","this_production","retval","setInput","canIUse","lexerInfo","errSymbolDescr","showPosition","join","ntsymbol","JisonLexerError","ERROR","__currentRuleSet__","__decompressed","done","_backtrack","_input","_more","_signaled_error_token","conditionStack","matched","matches","offset","yyleng","yylloc","constructLexErrorInfo","lexer_constructLexErrorInfo","show_input_position","indexOf","prettyPrintRange","pretty_src","test","pos_str","loc","destructLexErrorInfo","lexer_parseError","yyerror","yyError","lineno_msg","lexerErrorsAreRecoverable","args","slice","arguments","extra_error_attributes","lexer_cleanupAfterLex","clear","lexer_clear","col","last_column","first_line","first_column","last_line","range","lexer_setInput","rules","rule_re","conditions","spec","rule_ids","rule_regexes","rule_new_ids","__rule_regexes","__rule_count","editRemainingInput","lexer_editRemainingInput","callback","cpsArg","lexer_input","ch","slice_len","lines","ch2","unput","lexer_unput","split","substr","pre","pre_lines","more","lexer_more","reject","lexer_reject","backtrack_lexer","less","lexer_less","pastInput","lexer_pastInput","maxSize","maxLines","past","substring","replace","upcomingInput","lexer_upcomingInput","next","lexer_showPosition","maxPrefix","maxPostfix","deriveLocationInfo","lexer_deriveYYLLOC","actual","preceding","following","current","lexer_prettyPrintRange","context_loc","context_loc2","CONTEXT","CONTEXT_TAIL","MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT","l0","Math","max","l1","lineno_display_width","log10","ws_prefix","nonempty_line_indexes","map","injectLineNumber","index","lno","lno_pfx","errpfx","lead","mark","trim","clip_start","clip_end","intermediate_line","splice","describeYYLLOC","lexer_describe_yylloc","display_range_too","l2","c1","c2","dl","dc","r1","r2","test_match","lexer_test_match","indexed_rule","backup","match_str","match_str_len","lexer_next","tempMatch","_currentRules","trackPosition","topState","regexes","flex","pendingInput","activeCondition","conditionStackDepth","lexer_lex","lexer_fastLex","lexer_canIUse","begin","lexer_begin","condition","pushState","lexer_pushState","popState","lexer_popState","lexer_topState","abs","lexer__currentRules","stateStackSize","lexer_stateStackSize","lexer__performAction","yyrulenumber","YY_START","yy_","YYSTATE","simpleCaseActionClusters","inclusive","Parser","require","exports"],"sources":["C:/Users/user/Documents/GIEPS-Project/gogetit-ieps-frontend/node_modules/reduce-css-calc/dist/parser.js"],"sourcesContent":["\r\n/* parser generated by jison 0.6.1-215 */\r\n\r\n/*\r\n * Returns a Parser object of the following structure:\r\n *\r\n *  Parser: {\r\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n *               the real \"shared state\" `yy` passed around to\r\n *               the rule actions, etc. is a derivative/copy of this one,\r\n *               not a direct reference!\r\n *  }\r\n *\r\n *  Parser.prototype: {\r\n *    yy: {},\r\n *    EOF: 1,\r\n *    TERROR: 2,\r\n *\r\n *    trace: function(errorMessage, ...),\r\n *\r\n *    JisonParserError: function(msg, hash),\r\n *\r\n *    quoteName: function(name),\r\n *               Helper function which can be overridden by user code later on: put suitable\r\n *               quotes around literal IDs in a description string.\r\n *\r\n *    originalQuoteName: function(name),\r\n *               The basic quoteName handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `quoteName()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    describeSymbol: function(symbol),\r\n *               Return a more-or-less human-readable description of the given symbol, when\r\n *               available, or the symbol itself, serving as its own 'description' for lack\r\n *               of something better to serve up.\r\n *\r\n *               Return NULL when the symbol is unknown to the parser.\r\n *\r\n *    symbols_: {associative list: name ==> number},\r\n *    terminals_: {associative list: number ==> name},\r\n *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},\r\n *    terminal_descriptions_: (if there are any) {associative list: number ==> description},\r\n *    productions_: [...],\r\n *\r\n *    performAction: function parser__performAction(yytext, yyleng, yylineno, yyloc, yystate, yysp, yyvstack, yylstack, yystack, yysstack),\r\n *\r\n *               The function parameters and `this` have the following value/meaning:\r\n *               - `this`    : reference to the `yyval` internal object, which has members (`$` and `_$`)\r\n *                             to store/reference the rule value `$$` and location info `@$`.\r\n *\r\n *                 One important thing to note about `this` a.k.a. `yyval`: every *reduce* action gets\r\n *                 to see the same object via the `this` reference, i.e. if you wish to carry custom\r\n *                 data from one reduce action through to the next within a single parse run, then you\r\n *                 may get nasty and use `yyval` a.k.a. `this` for storing you own semi-permanent data.\r\n *\r\n *                 `this.yy` is a direct reference to the `yy` shared state object.\r\n *\r\n *                 `%parse-param`-specified additional `parse()` arguments have been added to this `yy`\r\n *                 object at `parse()` start and are therefore available to the action code via the\r\n *                 same named `yy.xxxx` attributes (where `xxxx` represents a identifier name from\r\n *                 the %parse-param` list.\r\n *\r\n *               - `yytext`  : reference to the lexer value which belongs to the last lexer token used\r\n *                             to match this rule. This is *not* the look-ahead token, but the last token\r\n *                             that's actually part of this rule.\r\n *\r\n *                 Formulated another way, `yytext` is the value of the token immediately preceeding\r\n *                 the current look-ahead token.\r\n *                 Caveats apply for rules which don't require look-ahead, such as epsilon rules.\r\n *\r\n *               - `yyleng`  : ditto as `yytext`, only now for the lexer.yyleng value.\r\n *\r\n *               - `yylineno`: ditto as `yytext`, only now for the lexer.yylineno value.\r\n *\r\n *               - `yyloc`   : ditto as `yytext`, only now for the lexer.yylloc lexer token location info.\r\n *\r\n *                               WARNING: since jison 0.4.18-186 this entry may be NULL/UNDEFINED instead\r\n *                               of an empty object when no suitable location info can be provided.\r\n *\r\n *               - `yystate` : the current parser state number, used internally for dispatching and\r\n *                               executing the action code chunk matching the rule currently being reduced.\r\n *\r\n *               - `yysp`    : the current state stack position (a.k.a. 'stack pointer')\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *                 Also note that you can access this and other stack index values using the new double-hash\r\n *                 syntax, i.e. `##$ === ##0 === yysp`, while `##1` is the stack index for all things\r\n *                 related to the first rule term, just like you have `$1`, `@1` and `#1`.\r\n *                 This is made available to write very advanced grammar action rules, e.g. when you want\r\n *                 to investigate the parse state stack in your action code, which would, for example,\r\n *                 be relevant when you wish to implement error diagnostics and reporting schemes similar\r\n *                 to the work described here:\r\n *\r\n *                 + Pottier, F., 2016. Reachability and error diagnosis in LR(1) automata.\r\n *                   In Journées Francophones des Languages Applicatifs.\r\n *\r\n *                 + Jeffery, C.L., 2003. Generating LR syntax error messages from examples.\r\n *                   ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5), pp.631–640.\r\n *\r\n *               - `yyrulelength`: the current rule's term count, i.e. the number of entries occupied on the stack.\r\n *\r\n *                 This one comes in handy when you are going to do advanced things to the parser\r\n *                 stacks, all of which are accessible from your action code (see the next entries below).\r\n *\r\n *               - `yyvstack`: reference to the parser value stack. Also accessed via the `$1` etc.\r\n *                             constructs.\r\n *\r\n *               - `yylstack`: reference to the parser token location stack. Also accessed via\r\n *                             the `@1` etc. constructs.\r\n *\r\n *                             WARNING: since jison 0.4.18-186 this array MAY contain slots which are\r\n *                             UNDEFINED rather than an empty (location) object, when the lexer/parser\r\n *                             action code did not provide a suitable location info object when such a\r\n *                             slot was filled!\r\n *\r\n *               - `yystack` : reference to the parser token id stack. Also accessed via the\r\n *                             `#1` etc. constructs.\r\n *\r\n *                 Note: this is a bit of a **white lie** as we can statically decode any `#n` reference to\r\n *                 its numeric token id value, hence that code wouldn't need the `yystack` but *you* might\r\n *                 want access this array for your own purposes, such as error analysis as mentioned above!\r\n *\r\n *                 Note that this stack stores the current stack of *tokens*, that is the sequence of\r\n *                 already parsed=reduced *nonterminals* (tokens representing rules) and *terminals*\r\n *                 (lexer tokens *shifted* onto the stack until the rule they belong to is found and\r\n *                 *reduced*.\r\n *\r\n *               - `yysstack`: reference to the parser state stack. This one carries the internal parser\r\n *                             *states* such as the one in `yystate`, which are used to represent\r\n *                             the parser state machine in the *parse table*. *Very* *internal* stuff,\r\n *                             what can I say? If you access this one, you're clearly doing wicked things\r\n *\r\n *               - `...`     : the extra arguments you specified in the `%parse-param` statement in your\r\n *                             grammar definition file.\r\n *\r\n *    table: [...],\r\n *               State transition table\r\n *               ----------------------\r\n *\r\n *               index levels are:\r\n *               - `state`  --> hash table\r\n *               - `symbol` --> action (number or array)\r\n *\r\n *                 If the `action` is an array, these are the elements' meaning:\r\n *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept\r\n *                 - index [1]: GOTO `state`\r\n *\r\n *                 If the `action` is a number, it is the GOTO `state`\r\n *\r\n *    defaultActions: {...},\r\n *\r\n *    parseError: function(str, hash, ExceptionClass),\r\n *    yyError: function(str, ...),\r\n *    yyRecovering: function(),\r\n *    yyErrOk: function(),\r\n *    yyClearIn: function(),\r\n *\r\n *    constructParseErrorInfo: function(error_message, exception_object, expected_token_set, is_recoverable),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n *               See it's use in this parser kernel in many places; example usage:\r\n *\r\n *                   var infoObj = parser.constructParseErrorInfo('fail!', null,\r\n *                                     parser.collect_expected_token_set(state), true);\r\n *                   var retVal = parser.parseError(infoObj.errStr, infoObj, parser.JisonParserError);\r\n *\r\n *    originalParseError: function(str, hash, ExceptionClass),\r\n *               The basic `parseError` handler provided by JISON.\r\n *               `cleanupAfterParse()` will clean up and reset `parseError()` to reference this function\r\n *               at the end of the `parse()`.\r\n *\r\n *    options: { ... parser %options ... },\r\n *\r\n *    parse: function(input[, args...]),\r\n *               Parse the given `input` and return the parsed value (or `true` when none was provided by\r\n *               the root action, in which case the parser is acting as a *matcher*).\r\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of this grammar:\r\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n *\r\n *               WARNING:\r\n *               Parser's additional `args...` parameters (via `%parse-param`) MAY conflict with\r\n *               any attributes already added to `yy` by the jison run-time;\r\n *               when such a collision is detected an exception is thrown to prevent the generated run-time\r\n *               from silently accepting this confusing and potentially hazardous situation!\r\n *\r\n *               The lexer MAY add its own set of additional parameters (via the `%parse-param` line in\r\n *               the lexer section of the grammar spec): these will be inserted in the `yy` shared state\r\n *               object and any collision with those will be reported by the lexer via a thrown exception.\r\n *\r\n *    cleanupAfterParse: function(resultValue, invoke_post_methods, do_not_nuke_errorinfos),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API is invoked at the end of the `parse()` call, unless an exception was thrown\r\n *               and `%options no-try-catch` has been defined for this grammar: in that case this helper MAY\r\n *               be invoked by calling user code to ensure the `post_parse` callbacks are invoked and\r\n *               the internal parser gets properly garbage collected under these particular circumstances.\r\n *\r\n *    yyMergeLocationInfo: function(first_index, last_index, first_yylloc, last_yylloc, dont_look_back),\r\n *               Helper function **which will be set up during the first invocation of the `parse()` method**.\r\n *               This helper API can be invoked to calculate a spanning `yylloc` location info object.\r\n *\r\n *               Note: %epsilon rules MAY specify no `first_index` and `first_yylloc`, in which case\r\n *               this function will attempt to obtain a suitable location marker by inspecting the location stack\r\n *               backwards.\r\n *\r\n *               For more info see the documentation comment further below, immediately above this function's\r\n *               implementation.\r\n *\r\n *    lexer: {\r\n *        yy: {...},           A reference to the so-called \"shared state\" `yy` once\r\n *                             received via a call to the `.setInput(input, yy)` lexer API.\r\n *        EOF: 1,\r\n *        ERROR: 2,\r\n *        JisonLexerError: function(msg, hash),\r\n *        parseError: function(str, hash, ExceptionClass),\r\n *        setInput: function(input, [yy]),\r\n *        input: function(),\r\n *        unput: function(str),\r\n *        more: function(),\r\n *        reject: function(),\r\n *        less: function(n),\r\n *        pastInput: function(n),\r\n *        upcomingInput: function(n),\r\n *        showPosition: function(),\r\n *        test_match: function(regex_match_array, rule_index, ...),\r\n *        next: function(...),\r\n *        lex: function(...),\r\n *        begin: function(condition),\r\n *        pushState: function(condition),\r\n *        popState: function(),\r\n *        topState: function(),\r\n *        _currentRules: function(),\r\n *        stateStackSize: function(),\r\n *        cleanupAfterLex: function()\r\n *\r\n *        options: { ... lexer %options ... },\r\n *\r\n *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START, ...),\r\n *        rules: [...],\r\n *        conditions: {associative list: name ==> set},\r\n *    }\r\n *  }\r\n *\r\n *\r\n *  token location info (@$, _$, etc.): {\r\n *    first_line: n,\r\n *    last_line: n,\r\n *    first_column: n,\r\n *    last_column: n,\r\n *    range: [start_number, end_number]\r\n *               (where the numbers are indexes into the input string, zero-based)\r\n *  }\r\n *\r\n * ---\r\n *\r\n * The `parseError` function receives a 'hash' object with these members for lexer and\r\n * parser errors:\r\n *\r\n *  {\r\n *    text:        (matched text)\r\n *    token:       (the produced terminal token, if any)\r\n *    token_id:    (the produced terminal token numeric ID, if any)\r\n *    line:        (yylineno)\r\n *    loc:         (yylloc)\r\n *  }\r\n *\r\n * parser (grammar) errors will also provide these additional members:\r\n *\r\n *  {\r\n *    expected:    (array describing the set of expected tokens;\r\n *                  may be UNDEFINED when we cannot easily produce such a set)\r\n *    state:       (integer (or array when the table includes grammar collisions);\r\n *                  represents the current internal state of the parser kernel.\r\n *                  can, for example, be used to pass to the `collect_expected_token_set()`\r\n *                  API to obtain the expected token set)\r\n *    action:      (integer; represents the current internal action which will be executed)\r\n *    new_state:   (integer; represents the next/planned internal state, once the current\r\n *                  action has executed)\r\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n *                  available for this particular error)\r\n *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n *                  as is also available in the rule actions; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    lexer:       (reference to the current lexer instance used by the parser)\r\n *    parser:      (reference to the current parser instance)\r\n *  }\r\n *\r\n * while `this` will reference the current parser instance.\r\n *\r\n * When `parseError` is invoked by the lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    lexer:       (reference to the current lexer instance which reported the error)\r\n *  }\r\n *\r\n * When `parseError` is invoked by the parser due to a **JavaScript exception** being fired\r\n * from either the parser or lexer, `this` will still reference the related *parser*\r\n * instance, while these additional `hash` fields will also be provided:\r\n *\r\n *  {\r\n *    exception:   (reference to the exception thrown)\r\n *  }\r\n *\r\n * Please do note that in the latter situation, the `expected` field will be omitted as\r\n * this type of failure is assumed not to be due to *parse errors* but rather due to user\r\n * action code in either parser or lexer failing unexpectedly.\r\n *\r\n * ---\r\n *\r\n * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.\r\n * These options are available:\r\n *\r\n * ### options which are global for all parser instances\r\n *\r\n *  Parser.pre_parse: function(yy)\r\n *                 optional: you can specify a pre_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`.\r\n *  Parser.post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: you can specify a post_parse() function in the chunk following\r\n *                 the grammar, i.e. after the last `%%`. When it does not return any value,\r\n *                 the parser will return the original `retval`.\r\n *\r\n * ### options which can be set up per parser instance\r\n *\r\n *  yy: {\r\n *      pre_parse:  function(yy)\r\n *                 optional: is invoked before the parse cycle starts (and before the first\r\n *                 invocation of `lex()`) but immediately after the invocation of\r\n *                 `parser.pre_parse()`).\r\n *      post_parse: function(yy, retval, parseInfo) { return retval; }\r\n *                 optional: is invoked when the parse terminates due to success ('accept')\r\n *                 or failure (even when exceptions are thrown).\r\n *                 `retval` contains the return value to be produced by `Parser.parse()`;\r\n *                 this function can override the return value by returning another.\r\n *                 When it does not return any value, the parser will return the original\r\n *                 `retval`.\r\n *                 This function is invoked immediately before `parser.post_parse()`.\r\n *\r\n *      parseError: function(str, hash, ExceptionClass)\r\n *                 optional: overrides the default `parseError` function.\r\n *      quoteName: function(name),\r\n *                 optional: overrides the default `quoteName` function.\r\n *  }\r\n *\r\n *  parser.lexer.options: {\r\n *      pre_lex:  function()\r\n *                 optional: is invoked before the lexer is invoked to produce another token.\r\n *                 `this` refers to the Lexer object.\r\n *      post_lex: function(token) { return token; }\r\n *                 optional: is invoked when the lexer has produced a token `token`;\r\n *                 this function can override the returned token value by returning another.\r\n *                 When it does not return any (truthy) value, the lexer will return\r\n *                 the original `token`.\r\n *                 `this` refers to the Lexer object.\r\n *\r\n *      ranges: boolean\r\n *                 optional: `true` ==> token location info will include a .range[] member.\r\n *      flex: boolean\r\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n *                 exhaustively to find the longest match.\r\n *      backtrack_lexer: boolean\r\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n *                 the lexer terminates the scan when a token is returned by the action code.\r\n *      xregexp: boolean\r\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n *                 `XRegExp` library. When this `%option` has not been specified at compile time, all lexer\r\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n *  }\r\n */\r\n\r\n        \r\n    \r\n            var parser = (function () {\r\n\r\n\r\n// See also:\r\n// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\r\n// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\r\n// with userland code which might access the derived class in a 'classic' way.\r\nfunction JisonParserError(msg, hash) {\r\n    Object.defineProperty(this, 'name', {\r\n        enumerable: false,\r\n        writable: false,\r\n        value: 'JisonParserError'\r\n    });\r\n\r\n    if (msg == null) msg = '???';\r\n\r\n    Object.defineProperty(this, 'message', {\r\n        enumerable: false,\r\n        writable: true,\r\n        value: msg\r\n    });\r\n\r\n    this.hash = hash;\r\n\r\n    var stacktrace;\r\n    if (hash && hash.exception instanceof Error) {\r\n        var ex2 = hash.exception;\r\n        this.message = ex2.message || msg;\r\n        stacktrace = ex2.stack;\r\n    }\r\n    if (!stacktrace) {\r\n        if (Error.hasOwnProperty('captureStackTrace')) {        // V8/Chrome engine\r\n            Error.captureStackTrace(this, this.constructor);\r\n        } else {\r\n            stacktrace = (new Error(msg)).stack;\r\n        }\r\n    }\r\n    if (stacktrace) {\r\n        Object.defineProperty(this, 'stack', {\r\n            enumerable: false,\r\n            writable: false,\r\n            value: stacktrace\r\n        });\r\n    }\r\n}\r\n\r\nif (typeof Object.setPrototypeOf === 'function') {\r\n    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);\r\n} else {\r\n    JisonParserError.prototype = Object.create(Error.prototype);\r\n}\r\nJisonParserError.prototype.constructor = JisonParserError;\r\nJisonParserError.prototype.name = 'JisonParserError';\r\n\r\n\r\n\r\n\r\n        // helper: reconstruct the productions[] table\r\n        function bp(s) {\r\n            var rv = [];\r\n            var p = s.pop;\r\n            var r = s.rule;\r\n            for (var i = 0, l = p.length; i < l; i++) {\r\n                rv.push([\r\n                    p[i],\r\n                    r[i]\r\n                ]);\r\n            }\r\n            return rv;\r\n        }\r\n    \r\n\r\n\r\n        // helper: reconstruct the defaultActions[] table\r\n        function bda(s) {\r\n            var rv = {};\r\n            var d = s.idx;\r\n            var g = s.goto;\r\n            for (var i = 0, l = d.length; i < l; i++) {\r\n                var j = d[i];\r\n                rv[j] = g[i];\r\n            }\r\n            return rv;\r\n        }\r\n    \r\n\r\n\r\n        // helper: reconstruct the 'goto' table\r\n        function bt(s) {\r\n            var rv = [];\r\n            var d = s.len;\r\n            var y = s.symbol;\r\n            var t = s.type;\r\n            var a = s.state;\r\n            var m = s.mode;\r\n            var g = s.goto;\r\n            for (var i = 0, l = d.length; i < l; i++) {\r\n                var n = d[i];\r\n                var q = {};\r\n                for (var j = 0; j < n; j++) {\r\n                    var z = y.shift();\r\n                    switch (t.shift()) {\r\n                    case 2:\r\n                        q[z] = [\r\n                            m.shift(),\r\n                            g.shift()\r\n                        ];\r\n                        break;\r\n\r\n                    case 0:\r\n                        q[z] = a.shift();\r\n                        break;\r\n\r\n                    default:\r\n                        // type === 1: accept\r\n                        q[z] = [\r\n                            3\r\n                        ];\r\n                    }\r\n                }\r\n                rv.push(q);\r\n            }\r\n            return rv;\r\n        }\r\n    \r\n\r\n\r\n        // helper: runlength encoding with increment step: code, length: step (default step = 0)\r\n        // `this` references an array\r\n        function s(c, l, a) {\r\n            a = a || 0;\r\n            for (var i = 0; i < l; i++) {\r\n                this.push(c);\r\n                c += a;\r\n            }\r\n        }\r\n\r\n        // helper: duplicate sequence from *relative* offset and length.\r\n        // `this` references an array\r\n        function c(i, l) {\r\n            i = this.length - i;\r\n            for (l += i; i < l; i++) {\r\n                this.push(this[i]);\r\n            }\r\n        }\r\n\r\n        // helper: unpack an array using helpers and data, all passed in an array argument 'a'.\r\n        function u(a) {\r\n            var rv = [];\r\n            for (var i = 0, l = a.length; i < l; i++) {\r\n                var e = a[i];\r\n                // Is this entry a helper function?\r\n                if (typeof e === 'function') {\r\n                    i++;\r\n                    e.apply(rv, a[i]);\r\n                } else {\r\n                    rv.push(e);\r\n                }\r\n            }\r\n            return rv;\r\n        }\r\n    \r\n\r\nvar parser = {\r\n    // Code Generator Information Report\r\n    // ---------------------------------\r\n    //\r\n    // Options:\r\n    //\r\n    //   default action mode: ............. [\"classic\",\"merge\"]\r\n    //   test-compile action mode: ........ \"parser:*,lexer:*\"\r\n    //   try..catch: ...................... true\r\n    //   default resolve on conflict: ..... true\r\n    //   on-demand look-ahead: ............ false\r\n    //   error recovery token skip maximum: 3\r\n    //   yyerror in parse actions is: ..... NOT recoverable,\r\n    //   yyerror in lexer actions and other non-fatal lexer are:\r\n    //   .................................. NOT recoverable,\r\n    //   debug grammar/output: ............ false\r\n    //   has partial LR conflict upgrade:   true\r\n    //   rudimentary token-stack support:   false\r\n    //   parser table compression mode: ... 2\r\n    //   export debug tables: ............. false\r\n    //   export *all* tables: ............. false\r\n    //   module type: ..................... commonjs\r\n    //   parser engine type: .............. lalr\r\n    //   output main() in the module: ..... true\r\n    //   has user-specified main(): ....... false\r\n    //   has user-specified require()/import modules for main():\r\n    //   .................................. false\r\n    //   number of expected conflicts: .... 0\r\n    //\r\n    //\r\n    // Parser Analysis flags:\r\n    //\r\n    //   no significant actions (parser is a language matcher only):\r\n    //   .................................. false\r\n    //   uses yyleng: ..................... false\r\n    //   uses yylineno: ................... false\r\n    //   uses yytext: ..................... false\r\n    //   uses yylloc: ..................... false\r\n    //   uses ParseError API: ............. false\r\n    //   uses YYERROR: .................... false\r\n    //   uses YYRECOVERING: ............... false\r\n    //   uses YYERROK: .................... false\r\n    //   uses YYCLEARIN: .................. false\r\n    //   tracks rule values: .............. true\r\n    //   assigns rule values: ............. true\r\n    //   uses location tracking: .......... false\r\n    //   assigns location: ................ false\r\n    //   uses yystack: .................... false\r\n    //   uses yysstack: ................... false\r\n    //   uses yysp: ....................... true\r\n    //   uses yyrulelength: ............... false\r\n    //   uses yyMergeLocationInfo API: .... false\r\n    //   has error recovery: .............. false\r\n    //   has error reporting: ............. false\r\n    //\r\n    // --------- END OF REPORT -----------\r\n\r\ntrace: function no_op_trace() { },\r\nJisonParserError: JisonParserError,\r\nyy: {},\r\noptions: {\r\n  type: \"lalr\",\r\n  hasPartialLrUpgradeOnConflict: true,\r\n  errorRecoveryTokenDiscardCount: 3\r\n},\r\nsymbols_: {\r\n  \"$accept\": 0,\r\n  \"$end\": 1,\r\n  \"ADD\": 3,\r\n  \"ANGLE\": 16,\r\n  \"CHS\": 22,\r\n  \"COMMA\": 14,\r\n  \"CSS_CPROP\": 13,\r\n  \"CSS_VAR\": 12,\r\n  \"DIV\": 6,\r\n  \"EMS\": 20,\r\n  \"EOF\": 1,\r\n  \"EXS\": 21,\r\n  \"FREQ\": 18,\r\n  \"LENGTH\": 15,\r\n  \"LPAREN\": 7,\r\n  \"MUL\": 5,\r\n  \"NESTED_CALC\": 9,\r\n  \"NUMBER\": 11,\r\n  \"PERCENTAGE\": 28,\r\n  \"PREFIX\": 10,\r\n  \"REMS\": 23,\r\n  \"RES\": 19,\r\n  \"RPAREN\": 8,\r\n  \"SUB\": 4,\r\n  \"TIME\": 17,\r\n  \"VHS\": 24,\r\n  \"VMAXS\": 27,\r\n  \"VMINS\": 26,\r\n  \"VWS\": 25,\r\n  \"css_value\": 33,\r\n  \"css_variable\": 32,\r\n  \"error\": 2,\r\n  \"expression\": 29,\r\n  \"math_expression\": 30,\r\n  \"value\": 31\r\n},\r\nterminals_: {\r\n  1: \"EOF\",\r\n  2: \"error\",\r\n  3: \"ADD\",\r\n  4: \"SUB\",\r\n  5: \"MUL\",\r\n  6: \"DIV\",\r\n  7: \"LPAREN\",\r\n  8: \"RPAREN\",\r\n  9: \"NESTED_CALC\",\r\n  10: \"PREFIX\",\r\n  11: \"NUMBER\",\r\n  12: \"CSS_VAR\",\r\n  13: \"CSS_CPROP\",\r\n  14: \"COMMA\",\r\n  15: \"LENGTH\",\r\n  16: \"ANGLE\",\r\n  17: \"TIME\",\r\n  18: \"FREQ\",\r\n  19: \"RES\",\r\n  20: \"EMS\",\r\n  21: \"EXS\",\r\n  22: \"CHS\",\r\n  23: \"REMS\",\r\n  24: \"VHS\",\r\n  25: \"VWS\",\r\n  26: \"VMINS\",\r\n  27: \"VMAXS\",\r\n  28: \"PERCENTAGE\"\r\n},\r\nTERROR: 2,\r\n    EOF: 1,\r\n\r\n    // internals: defined here so the object *structure* doesn't get modified by parse() et al,\r\n    // thus helping JIT compilers like Chrome V8.\r\n    originalQuoteName: null,\r\n    originalParseError: null,\r\n    cleanupAfterParse: null,\r\n    constructParseErrorInfo: null,\r\n    yyMergeLocationInfo: null,\r\n\r\n    __reentrant_call_depth: 0,      // INTERNAL USE ONLY\r\n    __error_infos: [],              // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\r\n    __error_recovery_infos: [],     // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup\r\n\r\n    // APIs which will be set up depending on user action code analysis:\r\n    //yyRecovering: 0,\r\n    //yyErrOk: 0,\r\n    //yyClearIn: 0,\r\n\r\n    // Helper APIs\r\n    // -----------\r\n\r\n    // Helper function which can be overridden by user code later on: put suitable quotes around\r\n    // literal IDs in a description string.\r\n    quoteName: function parser_quoteName(id_str) {\r\n        return '\"' + id_str + '\"';\r\n    },\r\n\r\n    // Return the name of the given symbol (terminal or non-terminal) as a string, when available.\r\n    //\r\n    // Return NULL when the symbol is unknown to the parser.\r\n    getSymbolName: function parser_getSymbolName(symbol) {\r\n        if (this.terminals_[symbol]) {\r\n            return this.terminals_[symbol];\r\n        }\r\n\r\n        // Otherwise... this might refer to a RULE token i.e. a non-terminal: see if we can dig that one up.\r\n        //\r\n        // An example of this may be where a rule's action code contains a call like this:\r\n        //\r\n        //      parser.getSymbolName(#$)\r\n        //\r\n        // to obtain a human-readable name of the current grammar rule.\r\n        var s = this.symbols_;\r\n        for (var key in s) {\r\n            if (s[key] === symbol) {\r\n                return key;\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    // Return a more-or-less human-readable description of the given symbol, when available,\r\n    // or the symbol itself, serving as its own 'description' for lack of something better to serve up.\r\n    //\r\n    // Return NULL when the symbol is unknown to the parser.\r\n    describeSymbol: function parser_describeSymbol(symbol) {\r\n        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {\r\n            return this.terminal_descriptions_[symbol];\r\n        }\r\n        else if (symbol === this.EOF) {\r\n            return 'end of input';\r\n        }\r\n        var id = this.getSymbolName(symbol);\r\n        if (id) {\r\n            return this.quoteName(id);\r\n        }\r\n        return null;\r\n    },\r\n\r\n    // Produce a (more or less) human-readable list of expected tokens at the point of failure.\r\n    //\r\n    // The produced list may contain token or token set descriptions instead of the tokens\r\n    // themselves to help turning this output into something that easier to read by humans\r\n    // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,\r\n    // expected terminals and nonterminals is produced.\r\n    //\r\n    // The returned list (array) will not contain any duplicate entries.\r\n    collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {\r\n        var TERROR = this.TERROR;\r\n        var tokenset = [];\r\n        var check = {};\r\n        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?\r\n        // If so, use that one instead of the less palatable token set.\r\n        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {\r\n            return [\r\n                this.state_descriptions_[state]\r\n            ];\r\n        }\r\n        for (var p in this.table[state]) {\r\n            p = +p;\r\n            if (p !== TERROR) {\r\n                var d = do_not_describe ? p : this.describeSymbol(p);\r\n                if (d && !check[d]) {\r\n                    tokenset.push(d);\r\n                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.\r\n                }\r\n            }\r\n        }\r\n        return tokenset;\r\n    },\r\nproductions_: bp({\r\n  pop: u([\r\n  29,\r\n  s,\r\n  [30, 10],\r\n  31,\r\n  31,\r\n  32,\r\n  32,\r\n  s,\r\n  [33, 15]\r\n]),\r\n  rule: u([\r\n  2,\r\n  s,\r\n  [3, 5],\r\n  4,\r\n  7,\r\n  s,\r\n  [1, 4],\r\n  2,\r\n  4,\r\n  6,\r\n  s,\r\n  [1, 14],\r\n  2\r\n])\r\n}),\r\nperformAction: function parser__PerformAction(yystate /* action[1] */, yysp, yyvstack) {\r\n\r\n          /* this == yyval */\r\n\r\n          // the JS engine itself can go and remove these statements when `yy` turns out to be unused in any action code!\r\n          var yy = this.yy;\r\n          var yyparser = yy.parser;\r\n          var yylexer = yy.lexer;\r\n\r\n          \r\n\r\n          switch (yystate) {\r\ncase 0:\r\n    /*! Production::    $accept : expression $end */\r\n\r\n    // default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-):\r\n    this.$ = yyvstack[yysp - 1];\r\n    // END of default action (generated by JISON mode classic/merge :: 1,VT,VA,-,-,-,-,-,-)\r\n    break;\r\n\r\ncase 1:\r\n    /*! Production::    expression : math_expression EOF */\r\n\r\n    // default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-):\r\n    this.$ = yyvstack[yysp - 1];\r\n    // END of default action (generated by JISON mode classic/merge :: 2,VT,VA,-,-,-,-,-,-)\r\n    \r\n    \r\n    return yyvstack[yysp - 1];\r\n    break;\r\n\r\ncase 2:\r\n    /*! Production::    math_expression : math_expression ADD math_expression */\r\ncase 3:\r\n    /*! Production::    math_expression : math_expression SUB math_expression */\r\ncase 4:\r\n    /*! Production::    math_expression : math_expression MUL math_expression */\r\ncase 5:\r\n    /*! Production::    math_expression : math_expression DIV math_expression */\r\n\r\n    this.$ = { type: 'MathExpression', operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };\r\n    break;\r\n\r\ncase 6:\r\n    /*! Production::    math_expression : LPAREN math_expression RPAREN */\r\n\r\n    this.$ = yyvstack[yysp - 1];\r\n    break;\r\n\r\ncase 7:\r\n    /*! Production::    math_expression : NESTED_CALC LPAREN math_expression RPAREN */\r\n\r\n    this.$ = { type: 'Calc', value: yyvstack[yysp - 1] };\r\n    break;\r\n\r\ncase 8:\r\n    /*! Production::    math_expression : SUB PREFIX SUB NESTED_CALC LPAREN math_expression RPAREN */\r\n\r\n    this.$ = { type: 'Calc', value: yyvstack[yysp - 1], prefix: yyvstack[yysp - 5] };\r\n    break;\r\n\r\ncase 9:\r\n    /*! Production::    math_expression : css_variable */\r\ncase 10:\r\n    /*! Production::    math_expression : css_value */\r\ncase 11:\r\n    /*! Production::    math_expression : value */\r\n\r\n    this.$ = yyvstack[yysp];\r\n    break;\r\n\r\ncase 12:\r\n    /*! Production::    value : NUMBER */\r\n\r\n    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) };\r\n    break;\r\n\r\ncase 13:\r\n    /*! Production::    value : SUB NUMBER */\r\n\r\n    this.$ = { type: 'Value', value: parseFloat(yyvstack[yysp]) * -1 };\r\n    break;\r\n\r\ncase 14:\r\n    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP RPAREN */\r\n\r\n    this.$ = { type: 'CssVariable', value: yyvstack[yysp - 1] };\r\n    break;\r\n\r\ncase 15:\r\n    /*! Production::    css_variable : CSS_VAR LPAREN CSS_CPROP COMMA math_expression RPAREN */\r\n\r\n    this.$ = { type: 'CssVariable', value: yyvstack[yysp - 3], fallback: yyvstack[yysp - 1] };\r\n    break;\r\n\r\ncase 16:\r\n    /*! Production::    css_value : LENGTH */\r\n\r\n    this.$ = { type: 'LengthValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\r\n    break;\r\n\r\ncase 17:\r\n    /*! Production::    css_value : ANGLE */\r\n\r\n    this.$ = { type: 'AngleValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\r\n    break;\r\n\r\ncase 18:\r\n    /*! Production::    css_value : TIME */\r\n\r\n    this.$ = { type: 'TimeValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\r\n    break;\r\n\r\ncase 19:\r\n    /*! Production::    css_value : FREQ */\r\n\r\n    this.$ = { type: 'FrequencyValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\r\n    break;\r\n\r\ncase 20:\r\n    /*! Production::    css_value : RES */\r\n\r\n    this.$ = { type: 'ResolutionValue', value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };\r\n    break;\r\n\r\ncase 21:\r\n    /*! Production::    css_value : EMS */\r\n\r\n    this.$ = { type: 'EmValue', value: parseFloat(yyvstack[yysp]), unit: 'em' };\r\n    break;\r\n\r\ncase 22:\r\n    /*! Production::    css_value : EXS */\r\n\r\n    this.$ = { type: 'ExValue', value: parseFloat(yyvstack[yysp]), unit: 'ex' };\r\n    break;\r\n\r\ncase 23:\r\n    /*! Production::    css_value : CHS */\r\n\r\n    this.$ = { type: 'ChValue', value: parseFloat(yyvstack[yysp]), unit: 'ch' };\r\n    break;\r\n\r\ncase 24:\r\n    /*! Production::    css_value : REMS */\r\n\r\n    this.$ = { type: 'RemValue', value: parseFloat(yyvstack[yysp]), unit: 'rem' };\r\n    break;\r\n\r\ncase 25:\r\n    /*! Production::    css_value : VHS */\r\n\r\n    this.$ = { type: 'VhValue', value: parseFloat(yyvstack[yysp]), unit: 'vh' };\r\n    break;\r\n\r\ncase 26:\r\n    /*! Production::    css_value : VWS */\r\n\r\n    this.$ = { type: 'VwValue', value: parseFloat(yyvstack[yysp]), unit: 'vw' };\r\n    break;\r\n\r\ncase 27:\r\n    /*! Production::    css_value : VMINS */\r\n\r\n    this.$ = { type: 'VminValue', value: parseFloat(yyvstack[yysp]), unit: 'vmin' };\r\n    break;\r\n\r\ncase 28:\r\n    /*! Production::    css_value : VMAXS */\r\n\r\n    this.$ = { type: 'VmaxValue', value: parseFloat(yyvstack[yysp]), unit: 'vmax' };\r\n    break;\r\n\r\ncase 29:\r\n    /*! Production::    css_value : PERCENTAGE */\r\n\r\n    this.$ = { type: 'PercentageValue', value: parseFloat(yyvstack[yysp]), unit: '%' };\r\n    break;\r\n\r\ncase 30:\r\n    /*! Production::    css_value : SUB css_value */\r\n\r\n    var prev = yyvstack[yysp]; prev.value *= -1; this.$ = prev;\r\n    break;\r\n\r\n}\r\n},\r\ntable: bt({\r\n  len: u([\r\n  24,\r\n  1,\r\n  5,\r\n  23,\r\n  1,\r\n  18,\r\n  s,\r\n  [0, 3],\r\n  1,\r\n  s,\r\n  [0, 16],\r\n  s,\r\n  [23, 4],\r\n  c,\r\n  [28, 3],\r\n  0,\r\n  0,\r\n  16,\r\n  1,\r\n  6,\r\n  6,\r\n  s,\r\n  [0, 3],\r\n  5,\r\n  1,\r\n  2,\r\n  c,\r\n  [37, 3],\r\n  c,\r\n  [20, 3],\r\n  5,\r\n  0,\r\n  0\r\n]),\r\n  symbol: u([\r\n  4,\r\n  7,\r\n  9,\r\n  11,\r\n  12,\r\n  s,\r\n  [15, 19, 1],\r\n  1,\r\n  1,\r\n  s,\r\n  [3, 4, 1],\r\n  c,\r\n  [30, 19],\r\n  c,\r\n  [29, 4],\r\n  7,\r\n  4,\r\n  10,\r\n  11,\r\n  c,\r\n  [22, 14],\r\n  c,\r\n  [19, 3],\r\n  c,\r\n  [43, 22],\r\n  c,\r\n  [23, 69],\r\n  c,\r\n  [139, 4],\r\n  8,\r\n  c,\r\n  [51, 24],\r\n  4,\r\n  c,\r\n  [138, 15],\r\n  13,\r\n  c,\r\n  [186, 5],\r\n  8,\r\n  c,\r\n  [6, 6],\r\n  c,\r\n  [5, 5],\r\n  9,\r\n  8,\r\n  14,\r\n  c,\r\n  [159, 47],\r\n  c,\r\n  [60, 10]\r\n]),\r\n  type: u([\r\n  s,\r\n  [2, 19],\r\n  s,\r\n  [0, 5],\r\n  1,\r\n  s,\r\n  [2, 24],\r\n  s,\r\n  [0, 4],\r\n  c,\r\n  [22, 19],\r\n  c,\r\n  [43, 42],\r\n  c,\r\n  [23, 70],\r\n  c,\r\n  [28, 25],\r\n  c,\r\n  [45, 25],\r\n  c,\r\n  [113, 54]\r\n]),\r\n  state: u([\r\n  1,\r\n  2,\r\n  8,\r\n  6,\r\n  7,\r\n  30,\r\n  c,\r\n  [4, 3],\r\n  33,\r\n  37,\r\n  c,\r\n  [5, 3],\r\n  38,\r\n  c,\r\n  [4, 3],\r\n  39,\r\n  c,\r\n  [4, 3],\r\n  40,\r\n  c,\r\n  [4, 3],\r\n  42,\r\n  c,\r\n  [21, 4],\r\n  50,\r\n  c,\r\n  [5, 3],\r\n  51,\r\n  c,\r\n  [4, 3]\r\n]),\r\n  mode: u([\r\n  s,\r\n  [1, 179],\r\n  s,\r\n  [2, 3],\r\n  c,\r\n  [5, 5],\r\n  c,\r\n  [6, 4],\r\n  s,\r\n  [1, 57]\r\n]),\r\n  goto: u([\r\n  5,\r\n  3,\r\n  4,\r\n  24,\r\n  s,\r\n  [9, 15, 1],\r\n  s,\r\n  [25, 5, 1],\r\n  c,\r\n  [24, 19],\r\n  31,\r\n  35,\r\n  32,\r\n  34,\r\n  c,\r\n  [18, 14],\r\n  36,\r\n  c,\r\n  [38, 19],\r\n  c,\r\n  [19, 57],\r\n  c,\r\n  [118, 4],\r\n  41,\r\n  c,\r\n  [24, 19],\r\n  43,\r\n  35,\r\n  c,\r\n  [16, 14],\r\n  44,\r\n  s,\r\n  [2, 3],\r\n  28,\r\n  29,\r\n  2,\r\n  s,\r\n  [3, 3],\r\n  28,\r\n  29,\r\n  3,\r\n  c,\r\n  [53, 4],\r\n  s,\r\n  [45, 5, 1],\r\n  c,\r\n  [100, 42],\r\n  52,\r\n  c,\r\n  [5, 4],\r\n  53\r\n])\r\n}),\r\ndefaultActions: bda({\r\n  idx: u([\r\n  6,\r\n  7,\r\n  8,\r\n  s,\r\n  [10, 16, 1],\r\n  33,\r\n  34,\r\n  39,\r\n  40,\r\n  41,\r\n  45,\r\n  47,\r\n  52,\r\n  53\r\n]),\r\n  goto: u([\r\n  9,\r\n  10,\r\n  11,\r\n  s,\r\n  [16, 14, 1],\r\n  12,\r\n  1,\r\n  30,\r\n  13,\r\n  s,\r\n  [4, 4, 1],\r\n  14,\r\n  15,\r\n  8\r\n])\r\n}),\r\nparseError: function parseError(str, hash, ExceptionClass) {\r\n    if (hash.recoverable) {\r\n        if (typeof this.trace === 'function') {\r\n            this.trace(str);\r\n        }\r\n        hash.destroy();             // destroy... well, *almost*!\r\n    } else {\r\n        if (typeof this.trace === 'function') {\r\n            this.trace(str);\r\n        }\r\n        if (!ExceptionClass) {\r\n            ExceptionClass = this.JisonParserError;\r\n        }\r\n        throw new ExceptionClass(str, hash);\r\n    }\r\n},\r\nparse: function parse(input) {\r\n    var self = this;\r\n    var stack = new Array(128);         // token stack: stores token which leads to state at the same index (column storage)\r\n    var sstack = new Array(128);        // state stack: stores states (column storage)\r\n\r\n    var vstack = new Array(128);        // semantic value stack\r\n\r\n    var table = this.table;\r\n    var sp = 0;                         // 'stack pointer': index into the stacks\r\n\r\n\r\n    \r\n\r\n\r\n    var symbol = 0;\r\n\r\n\r\n\r\n    var TERROR = this.TERROR;\r\n    var EOF = this.EOF;\r\n    var ERROR_RECOVERY_TOKEN_DISCARD_COUNT = (this.options.errorRecoveryTokenDiscardCount | 0) || 3;\r\n    var NO_ACTION = [0, 54 /* === table.length :: ensures that anyone using this new state will fail dramatically! */];\r\n\r\n    var lexer;\r\n    if (this.__lexer__) {\r\n        lexer = this.__lexer__;\r\n    } else {\r\n        lexer = this.__lexer__ = Object.create(this.lexer);\r\n    }\r\n\r\n    var sharedState_yy = {\r\n        parseError: undefined,\r\n        quoteName: undefined,\r\n        lexer: undefined,\r\n        parser: undefined,\r\n        pre_parse: undefined,\r\n        post_parse: undefined,\r\n        pre_lex: undefined,\r\n        post_lex: undefined      // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!\r\n    };\r\n\r\n    var ASSERT;\r\n    if (typeof assert !== 'function') {\r\n        ASSERT = function JisonAssert(cond, msg) {\r\n            if (!cond) {\r\n                throw new Error('assertion failed: ' + (msg || '***'));\r\n            }\r\n        };\r\n    } else {\r\n        ASSERT = assert;\r\n    }\r\n\r\n    this.yyGetSharedState = function yyGetSharedState() {\r\n        return sharedState_yy;\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function shallow_copy_noclobber(dst, src) {\r\n        for (var k in src) {\r\n            if (typeof dst[k] === 'undefined' && Object.prototype.hasOwnProperty.call(src, k)) {\r\n                dst[k] = src[k];\r\n            }\r\n        }\r\n    }\r\n\r\n    // copy state\r\n    shallow_copy_noclobber(sharedState_yy, this.yy);\r\n\r\n    sharedState_yy.lexer = lexer;\r\n    sharedState_yy.parser = this;\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Does the shared state override the default `parseError` that already comes with this instance?\r\n    if (typeof sharedState_yy.parseError === 'function') {\r\n        this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {\r\n            if (!ExceptionClass) {\r\n                ExceptionClass = this.JisonParserError;\r\n            }\r\n            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);\r\n        };\r\n    } else {\r\n        this.parseError = this.originalParseError;\r\n    }\r\n\r\n    // Does the shared state override the default `quoteName` that already comes with this instance?\r\n    if (typeof sharedState_yy.quoteName === 'function') {\r\n        this.quoteName = function quoteNameAlt(id_str) {\r\n            return sharedState_yy.quoteName.call(this, id_str);\r\n        };\r\n    } else {\r\n        this.quoteName = this.originalQuoteName;\r\n    }\r\n\r\n    // set up the cleanup function; make it an API so that external code can re-use this one in case of\r\n    // calamities or when the `%options no-try-catch` option has been specified for the grammar, in which\r\n    // case this parse() API method doesn't come with a `finally { ... }` block any more!\r\n    //\r\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\r\n    //       or else your `sharedState`, etc. references will be *wrong*!\r\n    this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {\r\n        var rv;\r\n\r\n        if (invoke_post_methods) {\r\n            var hash;\r\n\r\n            if (sharedState_yy.post_parse || this.post_parse) {\r\n                // create an error hash info instance: we re-use this API in a **non-error situation**\r\n                // as this one delivers all parser internals ready for access by userland code.\r\n                hash = this.constructParseErrorInfo(null /* no error! */, null /* no exception! */, null, false);\r\n            }\r\n\r\n            if (sharedState_yy.post_parse) {\r\n                rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);\r\n                if (typeof rv !== 'undefined') resultValue = rv;\r\n            }\r\n            if (this.post_parse) {\r\n                rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);\r\n                if (typeof rv !== 'undefined') resultValue = rv;\r\n            }\r\n\r\n            // cleanup:\r\n            if (hash && hash.destroy) {\r\n                hash.destroy();\r\n            }\r\n        }\r\n\r\n        if (this.__reentrant_call_depth > 1) return resultValue;        // do not (yet) kill the sharedState when this is a reentrant run.\r\n\r\n        // clean up the lingering lexer structures as well:\r\n        if (lexer.cleanupAfterLex) {\r\n            lexer.cleanupAfterLex(do_not_nuke_errorinfos);\r\n        }\r\n\r\n        // prevent lingering circular references from causing memory leaks:\r\n        if (sharedState_yy) {\r\n            sharedState_yy.lexer = undefined;\r\n            sharedState_yy.parser = undefined;\r\n            if (lexer.yy === sharedState_yy) {\r\n                lexer.yy = undefined;\r\n            }\r\n        }\r\n        sharedState_yy = undefined;\r\n        this.parseError = this.originalParseError;\r\n        this.quoteName = this.originalQuoteName;\r\n\r\n        // nuke the vstack[] array at least as that one will still reference obsoleted user values.\r\n        // To be safe, we nuke the other internal stack columns as well...\r\n        stack.length = 0;               // fastest way to nuke an array without overly bothering the GC\r\n        sstack.length = 0;\r\n\r\n        vstack.length = 0;\r\n        sp = 0;\r\n\r\n        // nuke the error hash info instances created during this run.\r\n        // Userland code must COPY any data/references\r\n        // in the error hash instance(s) it is more permanently interested in.\r\n        if (!do_not_nuke_errorinfos) {\r\n            for (var i = this.__error_infos.length - 1; i >= 0; i--) {\r\n                var el = this.__error_infos[i];\r\n                if (el && typeof el.destroy === 'function') {\r\n                    el.destroy();\r\n                }\r\n            }\r\n            this.__error_infos.length = 0;\r\n\r\n\r\n        }\r\n\r\n        return resultValue;\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // NOTE: as this API uses parse() as a closure, it MUST be set again on every parse() invocation,\r\n    //       or else your `lexer`, `sharedState`, etc. references will be *wrong*!\r\n    this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected, recoverable) {\r\n        var pei = {\r\n            errStr: msg,\r\n            exception: ex,\r\n            text: lexer.match,\r\n            value: lexer.yytext,\r\n            token: this.describeSymbol(symbol) || symbol,\r\n            token_id: symbol,\r\n            line: lexer.yylineno,\r\n\r\n            expected: expected,\r\n            recoverable: recoverable,\r\n            state: state,\r\n            action: action,\r\n            new_state: newState,\r\n            symbol_stack: stack,\r\n            state_stack: sstack,\r\n            value_stack: vstack,\r\n\r\n            stack_pointer: sp,\r\n            yy: sharedState_yy,\r\n            lexer: lexer,\r\n            parser: this,\r\n\r\n            // and make sure the error info doesn't stay due to potential\r\n            // ref cycle via userland code manipulations.\r\n            // These would otherwise all be memory leak opportunities!\r\n            //\r\n            // Note that only array and object references are nuked as those\r\n            // constitute the set of elements which can produce a cyclic ref.\r\n            // The rest of the members is kept intact as they are harmless.\r\n            destroy: function destructParseErrorInfo() {\r\n                // remove cyclic references added to error info:\r\n                // info.yy = null;\r\n                // info.lexer = null;\r\n                // info.value = null;\r\n                // info.value_stack = null;\r\n                // ...\r\n                var rec = !!this.recoverable;\r\n                for (var key in this) {\r\n                    if (this.hasOwnProperty(key) && typeof key === 'object') {\r\n                        this[key] = undefined;\r\n                    }\r\n                }\r\n                this.recoverable = rec;\r\n            }\r\n        };\r\n        // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\r\n        this.__error_infos.push(pei);\r\n        return pei;\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function getNonTerminalFromCode(symbol) {\r\n        var tokenName = self.getSymbolName(symbol);\r\n        if (!tokenName) {\r\n            tokenName = symbol;\r\n        }\r\n        return tokenName;\r\n    }\r\n\r\n\r\n    function stdLex() {\r\n        var token = lexer.lex();\r\n        // if token isn't its numeric value, convert\r\n        if (typeof token !== 'number') {\r\n            token = self.symbols_[token] || token;\r\n        }\r\n\r\n        return token || EOF;\r\n    }\r\n\r\n    function fastLex() {\r\n        var token = lexer.fastLex();\r\n        // if token isn't its numeric value, convert\r\n        if (typeof token !== 'number') {\r\n            token = self.symbols_[token] || token;\r\n        }\r\n\r\n        return token || EOF;\r\n    }\r\n\r\n    var lex = stdLex;\r\n\r\n\r\n    var state, action, r, t;\r\n    var yyval = {\r\n        $: true,\r\n        _$: undefined,\r\n        yy: sharedState_yy\r\n    };\r\n    var p;\r\n    var yyrulelen;\r\n    var this_production;\r\n    var newState;\r\n    var retval = false;\r\n\r\n\r\n    try {\r\n        this.__reentrant_call_depth++;\r\n\r\n        lexer.setInput(input, sharedState_yy);\r\n\r\n        // NOTE: we *assume* no lexer pre/post handlers are set up *after* \r\n        // this initial `setInput()` call: hence we can now check and decide\r\n        // whether we'll go with the standard, slower, lex() API or the\r\n        // `fast_lex()` one:\r\n        if (typeof lexer.canIUse === 'function') {\r\n            var lexerInfo = lexer.canIUse();\r\n            if (lexerInfo.fastLex && typeof fastLex === 'function') {\r\n                lex = fastLex;\r\n            }\r\n        } \r\n\r\n\r\n\r\n        vstack[sp] = null;\r\n        sstack[sp] = 0;\r\n        stack[sp] = 0;\r\n        ++sp;\r\n\r\n\r\n\r\n\r\n\r\n        if (this.pre_parse) {\r\n            this.pre_parse.call(this, sharedState_yy);\r\n        }\r\n        if (sharedState_yy.pre_parse) {\r\n            sharedState_yy.pre_parse.call(this, sharedState_yy);\r\n        }\r\n\r\n        newState = sstack[sp - 1];\r\n        for (;;) {\r\n            // retrieve state number from top of stack\r\n            state = newState;               // sstack[sp - 1];\r\n\r\n            // use default actions if available\r\n            if (this.defaultActions[state]) {\r\n                action = 2;\r\n                newState = this.defaultActions[state];\r\n            } else {\r\n                // The single `==` condition below covers both these `===` comparisons in a single\r\n                // operation:\r\n                //\r\n                //     if (symbol === null || typeof symbol === 'undefined') ...\r\n                if (!symbol) {\r\n                    symbol = lex();\r\n                }\r\n                // read action for current state and first input\r\n                t = (table[state] && table[state][symbol]) || NO_ACTION;\r\n                newState = t[1];\r\n                action = t[0];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // handle parse error\r\n                if (!action) {\r\n                    var errStr;\r\n                    var errSymbolDescr = (this.describeSymbol(symbol) || symbol);\r\n                    var expected = this.collect_expected_token_set(state);\r\n\r\n                    // Report error\r\n                    if (typeof lexer.yylineno === 'number') {\r\n                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';\r\n                    } else {\r\n                        errStr = 'Parse error: ';\r\n                    }\r\n                    if (typeof lexer.showPosition === 'function') {\r\n                        errStr += '\\n' + lexer.showPosition(79 - 10, 10) + '\\n';\r\n                    }\r\n                    if (expected.length) {\r\n                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + errSymbolDescr;\r\n                    } else {\r\n                        errStr += 'Unexpected ' + errSymbolDescr;\r\n                    }\r\n                    // we cannot recover from the error!\r\n                    p = this.constructParseErrorInfo(errStr, null, expected, false);\r\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\r\n                    if (typeof r !== 'undefined') {\r\n                        retval = r;\r\n                    }\r\n                    break;\r\n                }\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            switch (action) {\r\n            // catch misc. parse failures:\r\n            default:\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action instanceof Array) {\r\n                    p = this.constructParseErrorInfo('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, null, null, false);\r\n                    r = this.parseError(p.errStr, p, this.JisonParserError);\r\n                    if (typeof r !== 'undefined') {\r\n                        retval = r;\r\n                    }\r\n                    break;\r\n                }\r\n                // Another case of better safe than sorry: in case state transitions come out of another error recovery process\r\n                // or a buggy LUT (LookUp Table):\r\n                p = this.constructParseErrorInfo('Parsing halted. No viable error recovery approach available due to internal system failure.', null, null, false);\r\n                r = this.parseError(p.errStr, p, this.JisonParserError);\r\n                if (typeof r !== 'undefined') {\r\n                    retval = r;\r\n                }\r\n                break;\r\n\r\n            // shift:\r\n            case 1:\r\n                stack[sp] = symbol;\r\n                vstack[sp] = lexer.yytext;\r\n\r\n                sstack[sp] = newState; // push state\r\n\r\n                ++sp;\r\n                symbol = 0;\r\n\r\n\r\n\r\n\r\n                // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:\r\n\r\n\r\n\r\n\r\n                continue;\r\n\r\n            // reduce:\r\n            case 2:\r\n\r\n\r\n\r\n                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards...\r\n                yyrulelen = this_production[1];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                r = this.performAction.call(yyval, newState, sp - 1, vstack);\r\n\r\n                if (typeof r !== 'undefined') {\r\n                    retval = r;\r\n                    break;\r\n                }\r\n\r\n                // pop off stack\r\n                sp -= yyrulelen;\r\n\r\n                // don't overwrite the `symbol` variable: use a local var to speed things up:\r\n                var ntsymbol = this_production[0];    // push nonterminal (reduce)\r\n                stack[sp] = ntsymbol;\r\n                vstack[sp] = yyval.$;\r\n\r\n                // goto new state = table[STATE][NONTERMINAL]\r\n                newState = table[sstack[sp - 1]][ntsymbol];\r\n                sstack[sp] = newState;\r\n                ++sp;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                continue;\r\n\r\n            // accept:\r\n            case 3:\r\n                if (sp !== -2) {\r\n                    retval = true;\r\n                    // Return the `$accept` rule's `$$` result, if available.\r\n                    //\r\n                    // Also note that JISON always adds this top-most `$accept` rule (with implicit,\r\n                    // default, action):\r\n                    //\r\n                    //     $accept: <startSymbol> $end\r\n                    //                  %{ $$ = $1; @$ = @1; %}\r\n                    //\r\n                    // which, combined with the parse kernel's `$accept` state behaviour coded below,\r\n                    // will produce the `$$` value output of the <startSymbol> rule as the parse result,\r\n                    // IFF that result is *not* `undefined`. (See also the parser kernel code.)\r\n                    //\r\n                    // In code:\r\n                    //\r\n                    //                  %{\r\n                    //                      @$ = @1;            // if location tracking support is included\r\n                    //                      if (typeof $1 !== 'undefined')\r\n                    //                          return $1;\r\n                    //                      else\r\n                    //                          return true;           // the default parse result if the rule actions don't produce anything\r\n                    //                  %}\r\n                    sp--;\r\n                    if (typeof vstack[sp] !== 'undefined') {\r\n                        retval = vstack[sp];\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            // break out of loop: we accept or fail with error\r\n            break;\r\n        }\r\n    } catch (ex) {\r\n        // report exceptions through the parseError callback too, but keep the exception intact\r\n        // if it is a known parser or lexer error which has been thrown by parseError() already:\r\n        if (ex instanceof this.JisonParserError) {\r\n            throw ex;\r\n        }\r\n        else if (lexer && typeof lexer.JisonLexerError === 'function' && ex instanceof lexer.JisonLexerError) {\r\n            throw ex;\r\n        }\r\n\r\n        p = this.constructParseErrorInfo('Parsing aborted due to exception.', ex, null, false);\r\n        retval = false;\r\n        r = this.parseError(p.errStr, p, this.JisonParserError);\r\n        if (typeof r !== 'undefined') {\r\n            retval = r;\r\n        }\r\n    } finally {\r\n        retval = this.cleanupAfterParse(retval, true, true);\r\n        this.__reentrant_call_depth--;\r\n    }   // /finally\r\n\r\n    return retval;\r\n}\r\n};\r\nparser.originalParseError = parser.parseError;\r\nparser.originalQuoteName = parser.quoteName;\r\n/* lexer generated by jison-lex 0.6.1-215 */\r\n\r\n/*\r\n * Returns a Lexer object of the following structure:\r\n *\r\n *  Lexer: {\r\n *    yy: {}     The so-called \"shared state\" or rather the *source* of it;\r\n *               the real \"shared state\" `yy` passed around to\r\n *               the rule actions, etc. is a direct reference!\r\n *\r\n *               This \"shared context\" object was passed to the lexer by way of \r\n *               the `lexer.setInput(str, yy)` API before you may use it.\r\n *\r\n *               This \"shared context\" object is passed to the lexer action code in `performAction()`\r\n *               so userland code in the lexer actions may communicate with the outside world \r\n *               and/or other lexer rules' actions in more or less complex ways.\r\n *\r\n *  }\r\n *\r\n *  Lexer.prototype: {\r\n *    EOF: 1,\r\n *    ERROR: 2,\r\n *\r\n *    yy:        The overall \"shared context\" object reference.\r\n *\r\n *    JisonLexerError: function(msg, hash),\r\n *\r\n *    performAction: function lexer__performAction(yy, yyrulenumber, YY_START),\r\n *\r\n *               The function parameters and `this` have the following value/meaning:\r\n *               - `this`    : reference to the `lexer` instance. \r\n *                               `yy_` is an alias for `this` lexer instance reference used internally.\r\n *\r\n *               - `yy`      : a reference to the `yy` \"shared state\" object which was passed to the lexer\r\n *                             by way of the `lexer.setInput(str, yy)` API before.\r\n *\r\n *                             Note:\r\n *                             The extra arguments you specified in the `%parse-param` statement in your\r\n *                             **parser** grammar definition file are passed to the lexer via this object\r\n *                             reference as member variables.\r\n *\r\n *               - `yyrulenumber`   : index of the matched lexer rule (regex), used internally.\r\n *\r\n *               - `YY_START`: the current lexer \"start condition\" state.\r\n *\r\n *    parseError: function(str, hash, ExceptionClass),\r\n *\r\n *    constructLexErrorInfo: function(error_message, is_recoverable),\r\n *               Helper function.\r\n *               Produces a new errorInfo 'hash object' which can be passed into `parseError()`.\r\n *               See it's use in this lexer kernel in many places; example usage:\r\n *\r\n *                   var infoObj = lexer.constructParseErrorInfo('fail!', true);\r\n *                   var retVal = lexer.parseError(infoObj.errStr, infoObj, lexer.JisonLexerError);\r\n *\r\n *    options: { ... lexer %options ... },\r\n *\r\n *    lex: function(),\r\n *               Produce one token of lexed input, which was passed in earlier via the `lexer.setInput()` API.\r\n *               You MAY use the additional `args...` parameters as per `%parse-param` spec of the **lexer** grammar:\r\n *               these extra `args...` are added verbatim to the `yy` object reference as member variables.\r\n *\r\n *               WARNING:\r\n *               Lexer's additional `args...` parameters (via lexer's `%parse-param`) MAY conflict with\r\n *               any attributes already added to `yy` by the **parser** or the jison run-time; \r\n *               when such a collision is detected an exception is thrown to prevent the generated run-time \r\n *               from silently accepting this confusing and potentially hazardous situation! \r\n *\r\n *    cleanupAfterLex: function(do_not_nuke_errorinfos),\r\n *               Helper function.\r\n *\r\n *               This helper API is invoked when the **parse process** has completed: it is the responsibility\r\n *               of the **parser** (or the calling userland code) to invoke this method once cleanup is desired. \r\n *\r\n *               This helper may be invoked by user code to ensure the internal lexer gets properly garbage collected.\r\n *\r\n *    setInput: function(input, [yy]),\r\n *\r\n *\r\n *    input: function(),\r\n *\r\n *\r\n *    unput: function(str),\r\n *\r\n *\r\n *    more: function(),\r\n *\r\n *\r\n *    reject: function(),\r\n *\r\n *\r\n *    less: function(n),\r\n *\r\n *\r\n *    pastInput: function(n),\r\n *\r\n *\r\n *    upcomingInput: function(n),\r\n *\r\n *\r\n *    showPosition: function(),\r\n *\r\n *\r\n *    test_match: function(regex_match_array, rule_index),\r\n *\r\n *\r\n *    next: function(),\r\n *\r\n *\r\n *    begin: function(condition),\r\n *\r\n *\r\n *    pushState: function(condition),\r\n *\r\n *\r\n *    popState: function(),\r\n *\r\n *\r\n *    topState: function(),\r\n *\r\n *\r\n *    _currentRules: function(),\r\n *\r\n *\r\n *    stateStackSize: function(),\r\n *\r\n *\r\n *    performAction: function(yy, yy_, yyrulenumber, YY_START),\r\n *\r\n *\r\n *    rules: [...],\r\n *\r\n *\r\n *    conditions: {associative list: name ==> set},\r\n *  }\r\n *\r\n *\r\n *  token location info (`yylloc`): {\r\n *    first_line: n,\r\n *    last_line: n,\r\n *    first_column: n,\r\n *    last_column: n,\r\n *    range: [start_number, end_number]\r\n *               (where the numbers are indexes into the input string, zero-based)\r\n *  }\r\n *\r\n * ---\r\n *\r\n * The `parseError` function receives a 'hash' object with these members for lexer errors:\r\n *\r\n *  {\r\n *    text:        (matched text)\r\n *    token:       (the produced terminal token, if any)\r\n *    token_id:    (the produced terminal token numeric ID, if any)\r\n *    line:        (yylineno)\r\n *    loc:         (yylloc)\r\n *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule\r\n *                  available for this particular error)\r\n *    yy:          (object: the current parser internal \"shared state\" `yy`\r\n *                  as is also available in the rule actions; this can be used,\r\n *                  for instance, for advanced error analysis and reporting)\r\n *    lexer:       (reference to the current lexer instance used by the parser)\r\n *  }\r\n *\r\n * while `this` will reference the current lexer instance.\r\n *\r\n * When `parseError` is invoked by the lexer, the default implementation will\r\n * attempt to invoke `yy.parser.parseError()`; when this callback is not provided\r\n * it will try to invoke `yy.parseError()` instead. When that callback is also not\r\n * provided, a `JisonLexerError` exception will be thrown containing the error\r\n * message and `hash`, as constructed by the `constructLexErrorInfo()` API.\r\n *\r\n * Note that the lexer's `JisonLexerError` error class is passed via the\r\n * `ExceptionClass` argument, which is invoked to construct the exception\r\n * instance to be thrown, so technically `parseError` will throw the object\r\n * produced by the `new ExceptionClass(str, hash)` JavaScript expression.\r\n *\r\n * ---\r\n *\r\n * You can specify lexer options by setting / modifying the `.options` object of your Lexer instance.\r\n * These options are available:\r\n *\r\n * (Options are permanent.)\r\n *  \r\n *  yy: {\r\n *      parseError: function(str, hash, ExceptionClass)\r\n *                 optional: overrides the default `parseError` function.\r\n *  }\r\n *\r\n *  lexer.options: {\r\n *      pre_lex:  function()\r\n *                 optional: is invoked before the lexer is invoked to produce another token.\r\n *                 `this` refers to the Lexer object.\r\n *      post_lex: function(token) { return token; }\r\n *                 optional: is invoked when the lexer has produced a token `token`;\r\n *                 this function can override the returned token value by returning another.\r\n *                 When it does not return any (truthy) value, the lexer will return\r\n *                 the original `token`.\r\n *                 `this` refers to the Lexer object.\r\n *\r\n * WARNING: the next set of options are not meant to be changed. They echo the abilities of\r\n * the lexer as per when it was compiled!\r\n *\r\n *      ranges: boolean\r\n *                 optional: `true` ==> token location info will include a .range[] member.\r\n *      flex: boolean\r\n *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested\r\n *                 exhaustively to find the longest match.\r\n *      backtrack_lexer: boolean\r\n *                 optional: `true` ==> lexer regexes are tested in order and for invoked;\r\n *                 the lexer terminates the scan when a token is returned by the action code.\r\n *      xregexp: boolean\r\n *                 optional: `true` ==> lexer rule regexes are \"extended regex format\" requiring the\r\n *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer\r\n *                 rule regexes have been written as standard JavaScript RegExp expressions.\r\n *  }\r\n */\r\n\r\n\r\nvar lexer = function() {\r\n  /**\r\n   * See also:\r\n   * http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508\r\n   * but we keep the prototype.constructor and prototype.name assignment lines too for compatibility\r\n   * with userland code which might access the derived class in a 'classic' way.\r\n   *\r\n   * @public\r\n   * @constructor\r\n   * @nocollapse\r\n   */\r\n  function JisonLexerError(msg, hash) {\r\n    Object.defineProperty(this, 'name', {\r\n      enumerable: false,\r\n      writable: false,\r\n      value: 'JisonLexerError'\r\n    });\r\n\r\n    if (msg == null)\r\n      msg = '???';\r\n\r\n    Object.defineProperty(this, 'message', {\r\n      enumerable: false,\r\n      writable: true,\r\n      value: msg\r\n    });\r\n\r\n    this.hash = hash;\r\n    var stacktrace;\r\n\r\n    if (hash && hash.exception instanceof Error) {\r\n      var ex2 = hash.exception;\r\n      this.message = ex2.message || msg;\r\n      stacktrace = ex2.stack;\r\n    }\r\n\r\n    if (!stacktrace) {\r\n      if (Error.hasOwnProperty('captureStackTrace')) {\r\n        // V8\r\n        Error.captureStackTrace(this, this.constructor);\r\n      } else {\r\n        stacktrace = new Error(msg).stack;\r\n      }\r\n    }\r\n\r\n    if (stacktrace) {\r\n      Object.defineProperty(this, 'stack', {\r\n        enumerable: false,\r\n        writable: false,\r\n        value: stacktrace\r\n      });\r\n    }\r\n  }\r\n\r\n  if (typeof Object.setPrototypeOf === 'function') {\r\n    Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);\r\n  } else {\r\n    JisonLexerError.prototype = Object.create(Error.prototype);\r\n  }\r\n\r\n  JisonLexerError.prototype.constructor = JisonLexerError;\r\n  JisonLexerError.prototype.name = 'JisonLexerError';\r\n\r\n  var lexer = {\r\n    \r\n// Code Generator Information Report\r\n// ---------------------------------\r\n//\r\n// Options:\r\n//\r\n//   backtracking: .................... false\r\n//   location.ranges: ................. false\r\n//   location line+column tracking: ... true\r\n//\r\n//\r\n// Forwarded Parser Analysis flags:\r\n//\r\n//   uses yyleng: ..................... false\r\n//   uses yylineno: ................... false\r\n//   uses yytext: ..................... false\r\n//   uses yylloc: ..................... false\r\n//   uses lexer values: ............... true / true\r\n//   location tracking: ............... false\r\n//   location assignment: ............. false\r\n//\r\n//\r\n// Lexer Analysis flags:\r\n//\r\n//   uses yyleng: ..................... ???\r\n//   uses yylineno: ................... ???\r\n//   uses yytext: ..................... ???\r\n//   uses yylloc: ..................... ???\r\n//   uses ParseError API: ............. ???\r\n//   uses yyerror: .................... ???\r\n//   uses location tracking & editing:  ???\r\n//   uses more() API: ................. ???\r\n//   uses unput() API: ................ ???\r\n//   uses reject() API: ............... ???\r\n//   uses less() API: ................. ???\r\n//   uses display APIs pastInput(), upcomingInput(), showPosition():\r\n//        ............................. ???\r\n//   uses describeYYLLOC() API: ....... ???\r\n//\r\n// --------- END OF REPORT -----------\r\n\r\nEOF: 1,\r\n    ERROR: 2,\r\n\r\n    // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator\r\n\r\n    // options: {},                             /// <-- injected by the code generator\r\n\r\n    // yy: ...,                                 /// <-- injected by setInput()\r\n\r\n    __currentRuleSet__: null,                   /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  \r\n\r\n    __error_infos: [],                          /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  \r\n    __decompressed: false,                      /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  \r\n    done: false,                                /// INTERNAL USE ONLY  \r\n    _backtrack: false,                          /// INTERNAL USE ONLY  \r\n    _input: '',                                 /// INTERNAL USE ONLY  \r\n    _more: false,                               /// INTERNAL USE ONLY  \r\n    _signaled_error_token: false,               /// INTERNAL USE ONLY  \r\n    conditionStack: [],                         /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  \r\n    match: '',                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  \r\n    matched: '',                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  \r\n    matches: false,                             /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  \r\n    yytext: '',                                 /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  \r\n    offset: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  \r\n    yyleng: 0,                                  /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  \r\n    yylineno: 0,                                /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  \r\n    yylloc: null,                               /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  \r\n\r\n    /**\r\n     * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {\r\n      msg = '' + msg;\r\n\r\n      // heuristic to determine if the error message already contains a (partial) source code dump\r\n      // as produced by either `showPosition()` or `prettyPrintRange()`:\r\n      if (show_input_position == undefined) {\r\n        show_input_position = !(msg.indexOf('\\n') > 0 && msg.indexOf('^') > 0);\r\n      }\r\n\r\n      if (this.yylloc && show_input_position) {\r\n        if (typeof this.prettyPrintRange === 'function') {\r\n          var pretty_src = this.prettyPrintRange(this.yylloc);\r\n\r\n          if (!/\\n\\s*$/.test(msg)) {\r\n            msg += '\\n';\r\n          }\r\n\r\n          msg += '\\n  Erroneous area:\\n' + this.prettyPrintRange(this.yylloc);\r\n        } else if (typeof this.showPosition === 'function') {\r\n          var pos_str = this.showPosition();\r\n\r\n          if (pos_str) {\r\n            if (msg.length && msg[msg.length - 1] !== '\\n' && pos_str[0] !== '\\n') {\r\n              msg += '\\n' + pos_str;\r\n            } else {\r\n              msg += pos_str;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /** @constructor */\r\n      var pei = {\r\n        errStr: msg,\r\n        recoverable: !!recoverable,\r\n        text: this.match,           // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  \r\n        token: null,\r\n        line: this.yylineno,\r\n        loc: this.yylloc,\r\n        yy: this.yy,\r\n        lexer: this,\r\n\r\n        /**\r\n         * and make sure the error info doesn't stay due to potential\r\n         * ref cycle via userland code manipulations.\r\n         * These would otherwise all be memory leak opportunities!\r\n         * \r\n         * Note that only array and object references are nuked as those\r\n         * constitute the set of elements which can produce a cyclic ref.\r\n         * The rest of the members is kept intact as they are harmless.\r\n         * \r\n         * @public\r\n         * @this {LexErrorInfo}\r\n         */\r\n        destroy: function destructLexErrorInfo() {\r\n          // remove cyclic references added to error info:\r\n          // info.yy = null;\r\n          // info.lexer = null;\r\n          // ...\r\n          var rec = !!this.recoverable;\r\n\r\n          for (var key in this) {\r\n            if (this.hasOwnProperty(key) && typeof key === 'object') {\r\n              this[key] = undefined;\r\n            }\r\n          }\r\n\r\n          this.recoverable = rec;\r\n        }\r\n      };\r\n\r\n      // track this instance so we can `destroy()` it once we deem it superfluous and ready for garbage collection!\r\n      this.__error_infos.push(pei);\r\n\r\n      return pei;\r\n    },\r\n\r\n    /**\r\n     * handler which is invoked when a lexer error occurs.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    parseError: function lexer_parseError(str, hash, ExceptionClass) {\r\n      if (!ExceptionClass) {\r\n        ExceptionClass = this.JisonLexerError;\r\n      }\r\n\r\n      if (this.yy) {\r\n        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {\r\n          return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\r\n        } else if (typeof this.yy.parseError === 'function') {\r\n          return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;\r\n        }\r\n      }\r\n\r\n      throw new ExceptionClass(str, hash);\r\n    },\r\n\r\n    /**\r\n     * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    yyerror: function yyError(str /*, ...args */) {\r\n      var lineno_msg = '';\r\n\r\n      if (this.yylloc) {\r\n        lineno_msg = ' on line ' + (this.yylineno + 1);\r\n      }\r\n\r\n      var p = this.constructLexErrorInfo(\r\n        'Lexical error' + lineno_msg + ': ' + str,\r\n        this.options.lexerErrorsAreRecoverable\r\n      );\r\n\r\n      // Add any extra args to the hash under the name `extra_error_attributes`:\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n      if (args.length) {\r\n        p.extra_error_attributes = args;\r\n      }\r\n\r\n      return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n    },\r\n\r\n    /**\r\n     * final cleanup function for when we have completed lexing the input;\r\n     * make it an API so that external code can use this one once userland\r\n     * code has decided it's time to destroy any lingering lexer error\r\n     * hash object instances and the like: this function helps to clean\r\n     * up these constructs, which *may* carry cyclic references which would\r\n     * otherwise prevent the instances from being properly and timely\r\n     * garbage-collected, i.e. this function helps prevent memory leaks!\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {\r\n      // prevent lingering circular references from causing memory leaks:\r\n      this.setInput('', {});\r\n\r\n      // nuke the error hash info instances created during this run.\r\n      // Userland code must COPY any data/references\r\n      // in the error hash instance(s) it is more permanently interested in.\r\n      if (!do_not_nuke_errorinfos) {\r\n        for (var i = this.__error_infos.length - 1; i >= 0; i--) {\r\n          var el = this.__error_infos[i];\r\n\r\n          if (el && typeof el.destroy === 'function') {\r\n            el.destroy();\r\n          }\r\n        }\r\n\r\n        this.__error_infos.length = 0;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * clear the lexer token context; intended for internal use only\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    clear: function lexer_clear() {\r\n      this.yytext = '';\r\n      this.yyleng = 0;\r\n      this.match = '';\r\n\r\n      // - DO NOT reset `this.matched`\r\n      this.matches = false;\r\n\r\n      this._more = false;\r\n      this._backtrack = false;\r\n      var col = (this.yylloc ? this.yylloc.last_column : 0);\r\n\r\n      this.yylloc = {\r\n        first_line: this.yylineno + 1,\r\n        first_column: col,\r\n        last_line: this.yylineno + 1,\r\n        last_column: col,\r\n        range: [this.offset, this.offset]\r\n      };\r\n    },\r\n\r\n    /**\r\n     * resets the lexer, sets new input\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    setInput: function lexer_setInput(input, yy) {\r\n      this.yy = yy || this.yy || {};\r\n\r\n      // also check if we've fully initialized the lexer instance,\r\n      // including expansion work to be done to go from a loaded\r\n      // lexer to a usable lexer:\r\n      if (!this.__decompressed) {\r\n        // step 1: decompress the regex list:\r\n        var rules = this.rules;\r\n\r\n        for (var i = 0, len = rules.length; i < len; i++) {\r\n          var rule_re = rules[i];\r\n\r\n          // compression: is the RE an xref to another RE slot in the rules[] table?\r\n          if (typeof rule_re === 'number') {\r\n            rules[i] = rules[rule_re];\r\n          }\r\n        }\r\n\r\n        // step 2: unfold the conditions[] set to make these ready for use:\r\n        var conditions = this.conditions;\r\n\r\n        for (var k in conditions) {\r\n          var spec = conditions[k];\r\n          var rule_ids = spec.rules;\r\n          var len = rule_ids.length;\r\n          var rule_regexes = new Array(len + 1);             // slot 0 is unused; we use a 1-based index approach here to keep the hottest code in `lexer_next()` fast and simple! \r\n          var rule_new_ids = new Array(len + 1);\r\n\r\n          for (var i = 0; i < len; i++) {\r\n            var idx = rule_ids[i];\r\n            var rule_re = rules[idx];\r\n            rule_regexes[i + 1] = rule_re;\r\n            rule_new_ids[i + 1] = idx;\r\n          }\r\n\r\n          spec.rules = rule_new_ids;\r\n          spec.__rule_regexes = rule_regexes;\r\n          spec.__rule_count = len;\r\n        }\r\n\r\n        this.__decompressed = true;\r\n      }\r\n\r\n      this._input = input || '';\r\n      this.clear();\r\n      this._signaled_error_token = false;\r\n      this.done = false;\r\n      this.yylineno = 0;\r\n      this.matched = '';\r\n      this.conditionStack = ['INITIAL'];\r\n      this.__currentRuleSet__ = null;\r\n\r\n      this.yylloc = {\r\n        first_line: 1,\r\n        first_column: 0,\r\n        last_line: 1,\r\n        last_column: 0,\r\n        range: [0, 0]\r\n      };\r\n\r\n      this.offset = 0;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * edit the remaining input via user-specified callback.\r\n     * This can be used to forward-adjust the input-to-parse, \r\n     * e.g. inserting macro expansions and alike in the\r\n     * input which has yet to be lexed.\r\n     * The behaviour of this API contrasts the `unput()` et al\r\n     * APIs as those act on the *consumed* input, while this\r\n     * one allows one to manipulate the future, without impacting\r\n     * the current `yyloc` cursor location or any history. \r\n     * \r\n     * Use this API to help implement C-preprocessor-like\r\n     * `#include` statements, etc.\r\n     * \r\n     * The provided callback must be synchronous and is\r\n     * expected to return the edited input (string).\r\n     *\r\n     * The `cpsArg` argument value is passed to the callback\r\n     * as-is.\r\n     *\r\n     * `callback` interface: \r\n     * `function callback(input, cpsArg)`\r\n     * \r\n     * - `input` will carry the remaining-input-to-lex string\r\n     *   from the lexer.\r\n     * - `cpsArg` is `cpsArg` passed into this API.\r\n     * \r\n     * The `this` reference for the callback will be set to\r\n     * reference this lexer instance so that userland code\r\n     * in the callback can easily and quickly access any lexer\r\n     * API. \r\n     *\r\n     * When the callback returns a non-string-type falsey value,\r\n     * we assume the callback did not edit the input and we\r\n     * will using the input as-is.\r\n     *\r\n     * When the callback returns a non-string-type value, it\r\n     * is converted to a string for lexing via the `\"\" + retval`\r\n     * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html \r\n     * -- that way any returned object's `toValue()` and `toString()`\r\n     * methods will be invoked in a proper/desirable order.)\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {\r\n      var rv = callback.call(this, this._input, cpsArg);\r\n\r\n      if (typeof rv !== 'string') {\r\n        if (rv) {\r\n          this._input = '' + rv;\r\n        } \r\n        // else: keep `this._input` as is.  \r\n      } else {\r\n        this._input = rv;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * consumes and returns one char from the input\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    input: function lexer_input() {\r\n      if (!this._input) {\r\n        //this.done = true;    -- don't set `done` as we want the lex()/next() API to be able to produce one custom EOF token match after this anyhow. (lexer can match special <<EOF>> tokens and perform user action code for a <<EOF>> match, but only does so *once*)\r\n        return null;\r\n      }\r\n\r\n      var ch = this._input[0];\r\n      this.yytext += ch;\r\n      this.yyleng++;\r\n      this.offset++;\r\n      this.match += ch;\r\n      this.matched += ch;\r\n\r\n      // Count the linenumber up when we hit the LF (or a stand-alone CR).\r\n      // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo\r\n      // and we advance immediately past the LF as well, returning both together as if\r\n      // it was all a single 'character' only.\r\n      var slice_len = 1;\r\n\r\n      var lines = false;\r\n\r\n      if (ch === '\\n') {\r\n        lines = true;\r\n      } else if (ch === '\\r') {\r\n        lines = true;\r\n        var ch2 = this._input[1];\r\n\r\n        if (ch2 === '\\n') {\r\n          slice_len++;\r\n          ch += ch2;\r\n          this.yytext += ch2;\r\n          this.yyleng++;\r\n          this.offset++;\r\n          this.match += ch2;\r\n          this.matched += ch2;\r\n          this.yylloc.range[1]++;\r\n        }\r\n      }\r\n\r\n      if (lines) {\r\n        this.yylineno++;\r\n        this.yylloc.last_line++;\r\n        this.yylloc.last_column = 0;\r\n      } else {\r\n        this.yylloc.last_column++;\r\n      }\r\n\r\n      this.yylloc.range[1]++;\r\n      this._input = this._input.slice(slice_len);\r\n      return ch;\r\n    },\r\n\r\n    /**\r\n     * unshifts one char (or an entire string) into the input\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    unput: function lexer_unput(ch) {\r\n      var len = ch.length;\r\n      var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n      this._input = ch + this._input;\r\n      this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n      this.yyleng = this.yytext.length;\r\n      this.offset -= len;\r\n      this.match = this.match.substr(0, this.match.length - len);\r\n      this.matched = this.matched.substr(0, this.matched.length - len);\r\n\r\n      if (lines.length > 1) {\r\n        this.yylineno -= lines.length - 1;\r\n        this.yylloc.last_line = this.yylineno + 1;\r\n\r\n        // Get last entirely matched line into the `pre_lines[]` array's\r\n        // last index slot; we don't mind when other previously \r\n        // matched lines end up in the array too. \r\n        var pre = this.match;\r\n\r\n        var pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\r\n\r\n        if (pre_lines.length === 1) {\r\n          pre = this.matched;\r\n          pre_lines = pre.split(/(?:\\r\\n?|\\n)/g);\r\n        }\r\n\r\n        this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;\r\n      } else {\r\n        this.yylloc.last_column -= len;\r\n      }\r\n\r\n      this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;\r\n      this.done = false;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * cache matched text and append it on next action\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    more: function lexer_more() {\r\n      this._more = true;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * signal the lexer that this rule fails to match the input, so the\r\n     * next matching rule (regex) should be tested instead.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    reject: function lexer_reject() {\r\n      if (this.options.backtrack_lexer) {\r\n        this._backtrack = true;\r\n      } else {\r\n        // when the `parseError()` call returns, we MUST ensure that the error is registered.\r\n        // We accomplish this by signaling an 'error' token to be produced for the current\r\n        // `.lex()` run.\r\n        var lineno_msg = '';\r\n\r\n        if (this.yylloc) {\r\n          lineno_msg = ' on line ' + (this.yylineno + 1);\r\n        }\r\n\r\n        var p = this.constructLexErrorInfo(\r\n          'Lexical error' + lineno_msg + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).',\r\n          false\r\n        );\r\n\r\n        this._signaled_error_token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * retain first n characters of the match\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    less: function lexer_less(n) {\r\n      return this.unput(this.match.slice(n));\r\n    },\r\n\r\n    /**\r\n     * return (part of the) already matched input, i.e. for error\r\n     * messages.\r\n     * \r\n     * Limit the returned string length to `maxSize` (default: 20).\r\n     * \r\n     * Limit the returned string to the `maxLines` number of lines of\r\n     * input (default: 1).\r\n     * \r\n     * Negative limit values equal *unlimited*.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    pastInput: function lexer_pastInput(maxSize, maxLines) {\r\n      var past = this.matched.substring(0, this.matched.length - this.match.length);\r\n\r\n      if (maxSize < 0)\r\n        maxSize = past.length;\r\n      else if (!maxSize)\r\n        maxSize = 20;\r\n\r\n      if (maxLines < 0)\r\n        maxLines = past.length;          // can't ever have more input lines than this! \r\n      else if (!maxLines)\r\n        maxLines = 1;\r\n\r\n      // `substr` anticipation: treat \\r\\n as a single character and take a little\r\n      // more than necessary so that we can still properly check against maxSize\r\n      // after we've transformed and limited the newLines in here:\r\n      past = past.substr(-maxSize * 2 - 2);\r\n\r\n      // now that we have a significantly reduced string to process, transform the newlines\r\n      // and chop them, then limit them:\r\n      var a = past.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\r\n\r\n      a = a.slice(-maxLines);\r\n      past = a.join('\\n');\r\n\r\n      // When, after limiting to maxLines, we still have too much to return,\r\n      // do add an ellipsis prefix...\r\n      if (past.length > maxSize) {\r\n        past = '...' + past.substr(-maxSize);\r\n      }\r\n\r\n      return past;\r\n    },\r\n\r\n    /**\r\n     * return (part of the) upcoming input, i.e. for error messages.\r\n     * \r\n     * Limit the returned string length to `maxSize` (default: 20).\r\n     * \r\n     * Limit the returned string to the `maxLines` number of lines of input (default: 1).\r\n     * \r\n     * Negative limit values equal *unlimited*.\r\n     *\r\n     * > ### NOTE ###\r\n     * >\r\n     * > *\"upcoming input\"* is defined as the whole of the both\r\n     * > the *currently lexed* input, together with any remaining input\r\n     * > following that. *\"currently lexed\"* input is the input \r\n     * > already recognized by the lexer but not yet returned with\r\n     * > the lexer token. This happens when you are invoking this API\r\n     * > from inside any lexer rule action code block. \r\n     * >\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {\r\n      var next = this.match;\r\n\r\n      if (maxSize < 0)\r\n        maxSize = next.length + this._input.length;\r\n      else if (!maxSize)\r\n        maxSize = 20;\r\n\r\n      if (maxLines < 0)\r\n        maxLines = maxSize;          // can't ever have more input lines than this! \r\n      else if (!maxLines)\r\n        maxLines = 1;\r\n\r\n      // `substring` anticipation: treat \\r\\n as a single character and take a little\r\n      // more than necessary so that we can still properly check against maxSize\r\n      // after we've transformed and limited the newLines in here:\r\n      if (next.length < maxSize * 2 + 2) {\r\n        next += this._input.substring(0, maxSize * 2 + 2);   // substring is faster on Chrome/V8 \r\n      }\r\n\r\n      // now that we have a significantly reduced string to process, transform the newlines\r\n      // and chop them, then limit them:\r\n      var a = next.replace(/\\r\\n|\\r/g, '\\n').split('\\n');\r\n\r\n      a = a.slice(0, maxLines);\r\n      next = a.join('\\n');\r\n\r\n      // When, after limiting to maxLines, we still have too much to return,\r\n      // do add an ellipsis postfix...\r\n      if (next.length > maxSize) {\r\n        next = next.substring(0, maxSize) + '...';\r\n      }\r\n\r\n      return next;\r\n    },\r\n\r\n    /**\r\n     * return a string which displays the character position where the\r\n     * lexing error occurred, i.e. for error messages\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {\r\n      var pre = this.pastInput(maxPrefix).replace(/\\s/g, ' ');\r\n      var c = new Array(pre.length + 1).join('-');\r\n      return pre + this.upcomingInput(maxPostfix).replace(/\\s/g, ' ') + '\\n' + c + '^';\r\n    },\r\n\r\n    /**\r\n     * return an YYLLOC info object derived off the given context (actual, preceding, following, current).\r\n     * Use this method when the given `actual` location is not guaranteed to exist (i.e. when\r\n     * it MAY be NULL) and you MUST have a valid location info object anyway:\r\n     * then we take the given context of the `preceding` and `following` locations, IFF those are available,\r\n     * and reconstruct the `actual` location info from those.\r\n     * If this fails, the heuristic is to take the `current` location, IFF available.\r\n     * If this fails as well, we assume the sought location is at/around the current lexer position\r\n     * and then produce that one as a response. DO NOTE that these heuristic/derived location info\r\n     * values MAY be inaccurate!\r\n     *\r\n     * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just\r\n     * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {\r\n      var loc = {\r\n        first_line: 1,\r\n        first_column: 0,\r\n        last_line: 1,\r\n        last_column: 0,\r\n        range: [0, 0]\r\n      };\r\n\r\n      if (actual) {\r\n        loc.first_line = actual.first_line | 0;\r\n        loc.last_line = actual.last_line | 0;\r\n        loc.first_column = actual.first_column | 0;\r\n        loc.last_column = actual.last_column | 0;\r\n\r\n        if (actual.range) {\r\n          loc.range[0] = actual.range[0] | 0;\r\n          loc.range[1] = actual.range[1] | 0;\r\n        }\r\n      }\r\n\r\n      if (loc.first_line <= 0 || loc.last_line < loc.first_line) {\r\n        // plan B: heuristic using preceding and following:\r\n        if (loc.first_line <= 0 && preceding) {\r\n          loc.first_line = preceding.last_line | 0;\r\n          loc.first_column = preceding.last_column | 0;\r\n\r\n          if (preceding.range) {\r\n            loc.range[0] = actual.range[1] | 0;\r\n          }\r\n        }\r\n\r\n        if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {\r\n          loc.last_line = following.first_line | 0;\r\n          loc.last_column = following.first_column | 0;\r\n\r\n          if (following.range) {\r\n            loc.range[1] = actual.range[0] | 0;\r\n          }\r\n        }\r\n\r\n        // plan C?: see if the 'current' location is useful/sane too:\r\n        if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {\r\n          loc.first_line = current.first_line | 0;\r\n          loc.first_column = current.first_column | 0;\r\n\r\n          if (current.range) {\r\n            loc.range[0] = current.range[0] | 0;\r\n          }\r\n        }\r\n\r\n        if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {\r\n          loc.last_line = current.last_line | 0;\r\n          loc.last_column = current.last_column | 0;\r\n\r\n          if (current.range) {\r\n            loc.range[1] = current.range[1] | 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // sanitize: fix last_line BEFORE we fix first_line as we use the 'raw' value of the latter\r\n      // or plan D heuristics to produce a 'sensible' last_line value:\r\n      if (loc.last_line <= 0) {\r\n        if (loc.first_line <= 0) {\r\n          loc.first_line = this.yylloc.first_line;\r\n          loc.last_line = this.yylloc.last_line;\r\n          loc.first_column = this.yylloc.first_column;\r\n          loc.last_column = this.yylloc.last_column;\r\n          loc.range[0] = this.yylloc.range[0];\r\n          loc.range[1] = this.yylloc.range[1];\r\n        } else {\r\n          loc.last_line = this.yylloc.last_line;\r\n          loc.last_column = this.yylloc.last_column;\r\n          loc.range[1] = this.yylloc.range[1];\r\n        }\r\n      }\r\n\r\n      if (loc.first_line <= 0) {\r\n        loc.first_line = loc.last_line;\r\n        loc.first_column = 0;  // loc.last_column; \r\n        loc.range[1] = loc.range[0];\r\n      }\r\n\r\n      if (loc.first_column < 0) {\r\n        loc.first_column = 0;\r\n      }\r\n\r\n      if (loc.last_column < 0) {\r\n        loc.last_column = (loc.first_column > 0 ? loc.first_column : 80);\r\n      }\r\n\r\n      return loc;\r\n    },\r\n\r\n    /**\r\n     * return a string which displays the lines & columns of input which are referenced \r\n     * by the given location info range, plus a few lines of context.\r\n     * \r\n     * This function pretty-prints the indicated section of the input, with line numbers \r\n     * and everything!\r\n     * \r\n     * This function is very useful to provide highly readable error reports, while\r\n     * the location range may be specified in various flexible ways:\r\n     * \r\n     * - `loc` is the location info object which references the area which should be\r\n     *   displayed and 'marked up': these lines & columns of text are marked up by `^`\r\n     *   characters below each character in the entire input range.\r\n     * \r\n     * - `context_loc` is the *optional* location info object which instructs this\r\n     *   pretty-printer how much *leading* context should be displayed alongside\r\n     *   the area referenced by `loc`. This can help provide context for the displayed\r\n     *   error, etc.\r\n     * \r\n     *   When this location info is not provided, a default context of 3 lines is\r\n     *   used.\r\n     * \r\n     * - `context_loc2` is another *optional* location info object, which serves\r\n     *   a similar purpose to `context_loc`: it specifies the amount of *trailing*\r\n     *   context lines to display in the pretty-print output.\r\n     * \r\n     *   When this location info is not provided, a default context of 1 line only is\r\n     *   used.\r\n     * \r\n     * Special Notes:\r\n     * \r\n     * - when the `loc`-indicated range is very large (about 5 lines or more), then\r\n     *   only the first and last few lines of this block are printed while a\r\n     *   `...continued...` message will be printed between them.\r\n     * \r\n     *   This serves the purpose of not printing a huge amount of text when the `loc`\r\n     *   range happens to be huge: this way a manageable & readable output results\r\n     *   for arbitrary large ranges.\r\n     * \r\n     * - this function can display lines of input which whave not yet been lexed.\r\n     *   `prettyPrintRange()` can access the entire input!\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {\r\n      loc = this.deriveLocationInfo(loc, context_loc, context_loc2);\r\n      const CONTEXT = 3;\r\n      const CONTEXT_TAIL = 1;\r\n      const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;\r\n      var input = this.matched + this._input;\r\n      var lines = input.split('\\n');\r\n      var l0 = Math.max(1, (context_loc ? context_loc.first_line : loc.first_line - CONTEXT));\r\n      var l1 = Math.max(1, (context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL));\r\n      var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;\r\n      var ws_prefix = new Array(lineno_display_width).join(' ');\r\n      var nonempty_line_indexes = [];\r\n\r\n      var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {\r\n        var lno = index + l0;\r\n        var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);\r\n        var rv = lno_pfx + ': ' + line;\r\n        var errpfx = new Array(lineno_display_width + 1).join('^');\r\n        var offset = 2 + 1;\r\n        var len = 0;\r\n\r\n        if (lno === loc.first_line) {\r\n          offset += loc.first_column;\r\n\r\n          len = Math.max(\r\n            2,\r\n            ((lno === loc.last_line ? loc.last_column : line.length)) - loc.first_column + 1\r\n          );\r\n        } else if (lno === loc.last_line) {\r\n          len = Math.max(2, loc.last_column + 1);\r\n        } else if (lno > loc.first_line && lno < loc.last_line) {\r\n          len = Math.max(2, line.length + 1);\r\n        }\r\n\r\n        if (len) {\r\n          var lead = new Array(offset).join('.');\r\n          var mark = new Array(len).join('^');\r\n          rv += '\\n' + errpfx + lead + mark;\r\n\r\n          if (line.trim().length > 0) {\r\n            nonempty_line_indexes.push(index);\r\n          }\r\n        }\r\n\r\n        rv = rv.replace(/\\t/g, ' ');\r\n        return rv;\r\n      });\r\n\r\n      // now make sure we don't print an overly large amount of error area: limit it \r\n      // to the top and bottom line count:\r\n      if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {\r\n        var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;\r\n        var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;\r\n        var intermediate_line = new Array(lineno_display_width + 1).join(' ') + '  (...continued...)';\r\n        intermediate_line += '\\n' + new Array(lineno_display_width + 1).join('-') + '  (---------------)';\r\n        rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);\r\n      }\r\n\r\n      return rv.join('\\n');\r\n    },\r\n\r\n    /**\r\n     * helper function, used to produce a human readable description as a string, given\r\n     * the input `yylloc` location object.\r\n     * \r\n     * Set `display_range_too` to TRUE to include the string character index position(s)\r\n     * in the description if the `yylloc.range` is available.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {\r\n      var l1 = yylloc.first_line;\r\n      var l2 = yylloc.last_line;\r\n      var c1 = yylloc.first_column;\r\n      var c2 = yylloc.last_column;\r\n      var dl = l2 - l1;\r\n      var dc = c2 - c1;\r\n      var rv;\r\n\r\n      if (dl === 0) {\r\n        rv = 'line ' + l1 + ', ';\r\n\r\n        if (dc <= 1) {\r\n          rv += 'column ' + c1;\r\n        } else {\r\n          rv += 'columns ' + c1 + ' .. ' + c2;\r\n        }\r\n      } else {\r\n        rv = 'lines ' + l1 + '(column ' + c1 + ') .. ' + l2 + '(column ' + c2 + ')';\r\n      }\r\n\r\n      if (yylloc.range && display_range_too) {\r\n        var r1 = yylloc.range[0];\r\n        var r2 = yylloc.range[1] - 1;\r\n\r\n        if (r2 <= r1) {\r\n          rv += ' {String Offset: ' + r1 + '}';\r\n        } else {\r\n          rv += ' {String Offset range: ' + r1 + ' .. ' + r2 + '}';\r\n        }\r\n      }\r\n\r\n      return rv;\r\n    },\r\n\r\n    /**\r\n     * test the lexed token: return FALSE when not a match, otherwise return token.\r\n     * \r\n     * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`\r\n     * contains the actually matched text string.\r\n     * \r\n     * Also move the input cursor forward and update the match collectors:\r\n     * \r\n     * - `yytext`\r\n     * - `yyleng`\r\n     * - `match`\r\n     * - `matches`\r\n     * - `yylloc`\r\n     * - `offset`\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    test_match: function lexer_test_match(match, indexed_rule) {\r\n      var token, lines, backup, match_str, match_str_len;\r\n\r\n      if (this.options.backtrack_lexer) {\r\n        // save context\r\n        backup = {\r\n          yylineno: this.yylineno,\r\n\r\n          yylloc: {\r\n            first_line: this.yylloc.first_line,\r\n            last_line: this.yylloc.last_line,\r\n            first_column: this.yylloc.first_column,\r\n            last_column: this.yylloc.last_column,\r\n            range: this.yylloc.range.slice(0)\r\n          },\r\n\r\n          yytext: this.yytext,\r\n          match: this.match,\r\n          matches: this.matches,\r\n          matched: this.matched,\r\n          yyleng: this.yyleng,\r\n          offset: this.offset,\r\n          _more: this._more,\r\n          _input: this._input,\r\n\r\n          //_signaled_error_token: this._signaled_error_token,\r\n          yy: this.yy,\r\n\r\n          conditionStack: this.conditionStack.slice(0),\r\n          done: this.done\r\n        };\r\n      }\r\n\r\n      match_str = match[0];\r\n      match_str_len = match_str.length;\r\n\r\n      // if (match_str.indexOf('\\n') !== -1 || match_str.indexOf('\\r') !== -1) {\r\n      lines = match_str.split(/(?:\\r\\n?|\\n)/g);\r\n\r\n      if (lines.length > 1) {\r\n        this.yylineno += lines.length - 1;\r\n        this.yylloc.last_line = this.yylineno + 1;\r\n        this.yylloc.last_column = lines[lines.length - 1].length;\r\n      } else {\r\n        this.yylloc.last_column += match_str_len;\r\n      }\r\n\r\n      // }\r\n      this.yytext += match_str;\r\n\r\n      this.match += match_str;\r\n      this.matched += match_str;\r\n      this.matches = match;\r\n      this.yyleng = this.yytext.length;\r\n      this.yylloc.range[1] += match_str_len;\r\n\r\n      // previous lex rules MAY have invoked the `more()` API rather than producing a token:\r\n      // those rules will already have moved this `offset` forward matching their match lengths,\r\n      // hence we must only add our own match length now:\r\n      this.offset += match_str_len;\r\n\r\n      this._more = false;\r\n      this._backtrack = false;\r\n      this._input = this._input.slice(match_str_len);\r\n\r\n      // calling this method:\r\n      //\r\n      //   function lexer__performAction(yy, yyrulenumber, YY_START) {...}\r\n      token = this.performAction.call(\r\n        this,\r\n        this.yy,\r\n        indexed_rule,\r\n        this.conditionStack[this.conditionStack.length - 1] /* = YY_START */\r\n      );\r\n\r\n      // otherwise, when the action codes are all simple return token statements:\r\n      //token = this.simpleCaseActionClusters[indexed_rule];\r\n\r\n      if (this.done && this._input) {\r\n        this.done = false;\r\n      }\r\n\r\n      if (token) {\r\n        return token;\r\n      } else if (this._backtrack) {\r\n        // recover context\r\n        for (var k in backup) {\r\n          this[k] = backup[k];\r\n        }\r\n\r\n        this.__currentRuleSet__ = null;\r\n        return false;  // rule action called reject() implying the next rule should be tested instead. \r\n      } else if (this._signaled_error_token) {\r\n        // produce one 'error' token as `.parseError()` in `reject()`\r\n        // did not guarantee a failure signal by throwing an exception!\r\n        token = this._signaled_error_token;\r\n\r\n        this._signaled_error_token = false;\r\n        return token;\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * return next match in input\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    next: function lexer_next() {\r\n      if (this.done) {\r\n        this.clear();\r\n        return this.EOF;\r\n      }\r\n\r\n      if (!this._input) {\r\n        this.done = true;\r\n      }\r\n\r\n      var token, match, tempMatch, index;\r\n\r\n      if (!this._more) {\r\n        this.clear();\r\n      }\r\n\r\n      var spec = this.__currentRuleSet__;\r\n\r\n      if (!spec) {\r\n        // Update the ruleset cache as we apparently encountered a state change or just started lexing.\r\n        // The cache is set up for fast lookup -- we assume a lexer will switch states much less often than it will\r\n        // invoke the `lex()` token-producing API and related APIs, hence caching the set for direct access helps\r\n        // speed up those activities a tiny bit.\r\n        spec = this.__currentRuleSet__ = this._currentRules();\r\n\r\n        // Check whether a *sane* condition has been pushed before: this makes the lexer robust against\r\n        // user-programmer bugs such as https://github.com/zaach/jison-lex/issues/19\r\n        if (!spec || !spec.rules) {\r\n          var lineno_msg = '';\r\n\r\n          if (this.options.trackPosition) {\r\n            lineno_msg = ' on line ' + (this.yylineno + 1);\r\n          }\r\n\r\n          var p = this.constructLexErrorInfo(\r\n            'Internal lexer engine error' + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name \"' + this.topState() + '\"; this is a fatal error and should be reported to the application programmer team!',\r\n            false\r\n          );\r\n\r\n          // produce one 'error' token until this situation has been resolved, most probably by parse termination!\r\n          return this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n        }\r\n      }\r\n\r\n      var rule_ids = spec.rules;\r\n      var regexes = spec.__rule_regexes;\r\n      var len = spec.__rule_count;\r\n\r\n      // Note: the arrays are 1-based, while `len` itself is a valid index,\r\n      // hence the non-standard less-or-equal check in the next loop condition!\r\n      for (var i = 1; i <= len; i++) {\r\n        tempMatch = this._input.match(regexes[i]);\r\n\r\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n          match = tempMatch;\r\n          index = i;\r\n\r\n          if (this.options.backtrack_lexer) {\r\n            token = this.test_match(tempMatch, rule_ids[i]);\r\n\r\n            if (token !== false) {\r\n              return token;\r\n            } else if (this._backtrack) {\r\n              match = undefined;\r\n              continue;  // rule action called reject() implying a rule MISmatch. \r\n            } else {\r\n              // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n              return false;\r\n            }\r\n          } else if (!this.options.flex) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (match) {\r\n        token = this.test_match(match, rule_ids[index]);\r\n\r\n        if (token !== false) {\r\n          return token;\r\n        }\r\n\r\n        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n        return false;\r\n      }\r\n\r\n      if (!this._input) {\r\n        this.done = true;\r\n        this.clear();\r\n        return this.EOF;\r\n      } else {\r\n        var lineno_msg = '';\r\n\r\n        if (this.options.trackPosition) {\r\n          lineno_msg = ' on line ' + (this.yylineno + 1);\r\n        }\r\n\r\n        var p = this.constructLexErrorInfo(\r\n          'Lexical error' + lineno_msg + ': Unrecognized text.',\r\n          this.options.lexerErrorsAreRecoverable\r\n        );\r\n\r\n        var pendingInput = this._input;\r\n        var activeCondition = this.topState();\r\n        var conditionStackDepth = this.conditionStack.length;\r\n        token = this.parseError(p.errStr, p, this.JisonLexerError) || this.ERROR;\r\n\r\n        if (token === this.ERROR) {\r\n          // we can try to recover from a lexer error that `parseError()` did not 'recover' for us\r\n          // by moving forward at least one character at a time IFF the (user-specified?) `parseError()`\r\n          // has not consumed/modified any pending input or changed state in the error handler:\r\n          if (!this.matches && // and make sure the input has been modified/consumed ...\r\n          pendingInput === this._input && // ...or the lexer state has been modified significantly enough\r\n          // to merit a non-consuming error handling action right now.\r\n          activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {\r\n            this.input();\r\n          }\r\n        }\r\n\r\n        return token;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * return next match that has a token\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    lex: function lexer_lex() {\r\n      var r;\r\n\r\n      // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:\r\n      if (typeof this.pre_lex === 'function') {\r\n        r = this.pre_lex.call(this, 0);\r\n      }\r\n\r\n      if (typeof this.options.pre_lex === 'function') {\r\n        // (also account for a userdef function which does not return any value: keep the token as is)\r\n        r = this.options.pre_lex.call(this, r) || r;\r\n      }\r\n\r\n      if (this.yy && typeof this.yy.pre_lex === 'function') {\r\n        // (also account for a userdef function which does not return any value: keep the token as is)\r\n        r = this.yy.pre_lex.call(this, r) || r;\r\n      }\r\n\r\n      while (!r) {\r\n        r = this.next();\r\n      }\r\n\r\n      if (this.yy && typeof this.yy.post_lex === 'function') {\r\n        // (also account for a userdef function which does not return any value: keep the token as is)\r\n        r = this.yy.post_lex.call(this, r) || r;\r\n      }\r\n\r\n      if (typeof this.options.post_lex === 'function') {\r\n        // (also account for a userdef function which does not return any value: keep the token as is)\r\n        r = this.options.post_lex.call(this, r) || r;\r\n      }\r\n\r\n      if (typeof this.post_lex === 'function') {\r\n        // (also account for a userdef function which does not return any value: keep the token as is)\r\n        r = this.post_lex.call(this, r) || r;\r\n      }\r\n\r\n      return r;\r\n    },\r\n\r\n    /**\r\n     * return next match that has a token. Identical to the `lex()` API but does not invoke any of the \r\n     * `pre_lex()` nor any of the `post_lex()` callbacks.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    fastLex: function lexer_fastLex() {\r\n      var r;\r\n\r\n      while (!r) {\r\n        r = this.next();\r\n      }\r\n\r\n      return r;\r\n    },\r\n\r\n    /**\r\n     * return info about the lexer state that can help a parser or other lexer API user to use the\r\n     * most efficient means available. This API is provided to aid run-time performance for larger\r\n     * systems which employ this lexer.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    canIUse: function lexer_canIUse() {\r\n      var rv = {\r\n        fastLex: !(typeof this.pre_lex === 'function' || typeof this.options.pre_lex === 'function' || this.yy && typeof this.yy.pre_lex === 'function' || this.yy && typeof this.yy.post_lex === 'function' || typeof this.options.post_lex === 'function' || typeof this.post_lex === 'function') && typeof this.fastLex === 'function'\r\n      };\r\n\r\n      return rv;\r\n    },\r\n\r\n    /**\r\n     * backwards compatible alias for `pushState()`;\r\n     * the latter is symmetrical with `popState()` and we advise to use\r\n     * those APIs in any modern lexer code, rather than `begin()`.\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    begin: function lexer_begin(condition) {\r\n      return this.pushState(condition);\r\n    },\r\n\r\n    /**\r\n     * activates a new lexer condition state (pushes the new lexer\r\n     * condition state onto the condition stack)\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    pushState: function lexer_pushState(condition) {\r\n      this.conditionStack.push(condition);\r\n      this.__currentRuleSet__ = null;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * pop the previously active lexer condition state off the condition\r\n     * stack\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    popState: function lexer_popState() {\r\n      var n = this.conditionStack.length - 1;\r\n\r\n      if (n > 0) {\r\n        this.__currentRuleSet__ = null;\r\n        return this.conditionStack.pop();\r\n      } else {\r\n        return this.conditionStack[0];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * return the currently active lexer condition state; when an index\r\n     * argument is provided it produces the N-th previous condition state,\r\n     * if available\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    topState: function lexer_topState(n) {\r\n      n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n\r\n      if (n >= 0) {\r\n        return this.conditionStack[n];\r\n      } else {\r\n        return 'INITIAL';\r\n      }\r\n    },\r\n\r\n    /**\r\n     * (internal) determine the lexer rule set which is active for the\r\n     * currently active lexer condition state\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    _currentRules: function lexer__currentRules() {\r\n      if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n        return this.conditions[this.conditionStack[this.conditionStack.length - 1]];\r\n      } else {\r\n        return this.conditions['INITIAL'];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * return the number of states currently on the stack\r\n     * \r\n     * @public\r\n     * @this {RegExpLexer}\r\n     */\r\n    stateStackSize: function lexer_stateStackSize() {\r\n      return this.conditionStack.length;\r\n    },\r\n\r\n    options: {\r\n      trackPosition: true\r\n    },\r\n\r\n    JisonLexerError: JisonLexerError,\r\n\r\n    performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {\r\n      var yy_ = this;\r\n      var YYSTATE = YY_START;\r\n\r\n      switch (yyrulenumber) {\r\n      case 1:\r\n        /*! Conditions:: INITIAL */\r\n        /*! Rule::       \\s+ */\r\n        /* skip whitespace */\r\n        break;\r\n\r\n      default:\r\n        return this.simpleCaseActionClusters[yyrulenumber];\r\n      }\r\n    },\r\n\r\n    simpleCaseActionClusters: {\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       (--[0-9a-z-A-Z-]*) */\r\n      0: 13,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       \\* */\r\n      2: 5,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       \\/ */\r\n      3: 6,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       \\+ */\r\n      4: 3,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       - */\r\n      5: 4,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)px\\b */\r\n      6: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)cm\\b */\r\n      7: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)mm\\b */\r\n      8: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)in\\b */\r\n      9: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pt\\b */\r\n      10: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)pc\\b */\r\n      11: 15,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)deg\\b */\r\n      12: 16,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)grad\\b */\r\n      13: 16,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rad\\b */\r\n      14: 16,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)turn\\b */\r\n      15: 16,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)s\\b */\r\n      16: 17,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ms\\b */\r\n      17: 17,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)Hz\\b */\r\n      18: 18,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)kHz\\b */\r\n      19: 18,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpi\\b */\r\n      20: 19,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dpcm\\b */\r\n      21: 19,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)dppx\\b */\r\n      22: 19,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)em\\b */\r\n      23: 20,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ex\\b */\r\n      24: 21,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)ch\\b */\r\n      25: 22,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)rem\\b */\r\n      26: 23,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vw\\b */\r\n      27: 25,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vh\\b */\r\n      28: 24,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmin\\b */\r\n      29: 26,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)vmax\\b */\r\n      30: 27,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)% */\r\n      31: 28,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([0-9]+(\\.[0-9]*)?|\\.[0-9]+)\\b */\r\n      32: 11,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       (calc) */\r\n      33: 9,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       (var) */\r\n      34: 12,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       ([a-z]+) */\r\n      35: 10,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       \\( */\r\n      36: 7,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       \\) */\r\n      37: 8,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       , */\r\n      38: 14,\r\n\r\n      /*! Conditions:: INITIAL */\r\n      /*! Rule::       $ */\r\n      39: 1\r\n    },\r\n\r\n    rules: [\r\n      /*  0: */  /^(?:(--[\\d\\-A-Za-z]*))/,\r\n      /*  1: */  /^(?:\\s+)/,\r\n      /*  2: */  /^(?:\\*)/,\r\n      /*  3: */  /^(?:\\/)/,\r\n      /*  4: */  /^(?:\\+)/,\r\n      /*  5: */  /^(?:-)/,\r\n      /*  6: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)px\\b)/,\r\n      /*  7: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)cm\\b)/,\r\n      /*  8: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)mm\\b)/,\r\n      /*  9: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)in\\b)/,\r\n      /* 10: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pt\\b)/,\r\n      /* 11: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)pc\\b)/,\r\n      /* 12: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)deg\\b)/,\r\n      /* 13: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)grad\\b)/,\r\n      /* 14: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rad\\b)/,\r\n      /* 15: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)turn\\b)/,\r\n      /* 16: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)s\\b)/,\r\n      /* 17: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ms\\b)/,\r\n      /* 18: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)Hz\\b)/,\r\n      /* 19: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)kHz\\b)/,\r\n      /* 20: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpi\\b)/,\r\n      /* 21: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dpcm\\b)/,\r\n      /* 22: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)dppx\\b)/,\r\n      /* 23: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)em\\b)/,\r\n      /* 24: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ex\\b)/,\r\n      /* 25: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)ch\\b)/,\r\n      /* 26: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)rem\\b)/,\r\n      /* 27: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vw\\b)/,\r\n      /* 28: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vh\\b)/,\r\n      /* 29: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmin\\b)/,\r\n      /* 30: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)vmax\\b)/,\r\n      /* 31: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)%)/,\r\n      /* 32: */  /^(?:(\\d+(\\.\\d*)?|\\.\\d+)\\b)/,\r\n      /* 33: */  /^(?:(calc))/,\r\n      /* 34: */  /^(?:(var))/,\r\n      /* 35: */  /^(?:([a-z]+))/,\r\n      /* 36: */  /^(?:\\()/,\r\n      /* 37: */  /^(?:\\))/,\r\n      /* 38: */  /^(?:,)/,\r\n      /* 39: */  /^(?:$)/\r\n    ],\r\n\r\n    conditions: {\r\n      'INITIAL': {\r\n        rules: [\r\n          0,\r\n          1,\r\n          2,\r\n          3,\r\n          4,\r\n          5,\r\n          6,\r\n          7,\r\n          8,\r\n          9,\r\n          10,\r\n          11,\r\n          12,\r\n          13,\r\n          14,\r\n          15,\r\n          16,\r\n          17,\r\n          18,\r\n          19,\r\n          20,\r\n          21,\r\n          22,\r\n          23,\r\n          24,\r\n          25,\r\n          26,\r\n          27,\r\n          28,\r\n          29,\r\n          30,\r\n          31,\r\n          32,\r\n          33,\r\n          34,\r\n          35,\r\n          36,\r\n          37,\r\n          38,\r\n          39\r\n        ],\r\n\r\n        inclusive: true\r\n      }\r\n    }\r\n  };\r\n\r\n  return lexer;\r\n}();\r\nparser.lexer = lexer;\r\n\r\n\r\n\r\nfunction Parser() {\r\n  this.yy = {};\r\n}\r\nParser.prototype = parser;\r\nparser.Parser = Parser;\r\n\r\nreturn new Parser();\r\n})();\r\n\r\n        \r\n\r\n\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n  exports.parser = parser;\r\n  exports.Parser = parser.Parser;\r\n  exports.parse = function () {\r\n    return parser.parse.apply(parser, arguments);\r\n  };\r\n  \r\n}\r\n"],"mappings":"AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIY,IAAIA,MAAM,GAAI,YAAY;EAGtC;EACA;EACA;EACA;EACA,SAASC,gBAAT,CAA0BC,GAA1B,EAA+BC,IAA/B,EAAqC;IACjCC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,MAA5B,EAAoC;MAChCC,UAAU,EAAE,KADoB;MAEhCC,QAAQ,EAAE,KAFsB;MAGhCC,KAAK,EAAE;IAHyB,CAApC;IAMA,IAAIN,GAAG,IAAI,IAAX,EAAiBA,GAAG,GAAG,KAAN;IAEjBE,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;MACnCC,UAAU,EAAE,KADuB;MAEnCC,QAAQ,EAAE,IAFyB;MAGnCC,KAAK,EAAEN;IAH4B,CAAvC;IAMA,KAAKC,IAAL,GAAYA,IAAZ;IAEA,IAAIM,UAAJ;;IACA,IAAIN,IAAI,IAAIA,IAAI,CAACO,SAAL,YAA0BC,KAAtC,EAA6C;MACzC,IAAIC,GAAG,GAAGT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;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGA,IAAIyB,KAAK,GAAG,YAAW;IACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE,SAASyF,eAAT,CAAyB3L,GAAzB,EAA8BC,IAA9B,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"},"metadata":{},"sourceType":"script"}